#                                                         前端基础知识学习笔记

> 心得体会
>
> * 在写一段代码的时候一定要先想清楚该怎么写，怎么写才可以达到最便捷迅速的目的；在写的过程当中，要知道你的每一段代码在干什么，并且要不断地更新代码,==关键代码一定要注释==
> * 多总结，多尝试；多看视频，多独立练习项目

##                                                                              HTML

#### 基本结构

| DOCTYPE     | 声明为HTML文档                                  |
| ----------- | ----------------------------------------------- |
| html        | lang:网页的语言，如en/zh等，非必选项目          |
| head        | 文档说明部分，对搜索引擎提供信息或加载CSS、JS等 |
| title       | 网页标题                                        |
| keyword     | 向搜索引擎说明你的网页的关键词                  |
| description | 向搜索引擎描述网页内容的摘要信息                |
| body        | 页面主体内容                                    |



==文件的命名应当使用小写英文==



#### HTML--表格

1：表格的基本组成

```html
<table>
<tr><td></td></tr>
<tr><td></td></tr>
</table>
```



table表示一个表格区域，tr管理行数，td管理列数，th管理表头，tbody管理表格主体，thead管理表格的页眉，tfoot管理表格的页脚

2：管理单元格边沿与其内容之间的空白（cellpadding）;

3:管理单元格之间的空间（cellspacing）;

==2和3通常都是直接嵌入到html区域里面，建议不要使用，而是使用CSS来控制表格的样式==

4:表格的标题定义:`<caption></caption>`,紧随<table>之后

5：rowspan=“3”-----表示跨3行

6：colspan="3"----表示跨3列



#### HTML--表单

1：文本框
姓名：`<input type="text" name="userName"/>`//type="text"表示普通文本输入，可以设置maxlength

2：密码框
密码：`<input type="password" name="pwd" value="123456"/>`//type="password"表示密码的输入

3：单选框
`<input type="radio" name="sex" value="male" checked/>`//type="radio",表示单选框

`<input type="radio" name="sex" value="female"/>`

在文本框里边可以使用placeholder来设置它的默认显示文本；可以==通过输入框伪类形式来控制默认显示文本的样式==：

```css
input:placeholder{
color:white;
fontsize:18px;
padding-left:5px;
}
```



通过设置input里面的type来更改input的类型，name是用来命名该input，通过这样来使服务器标识收到的信息；value是用来设置文本框的实际值；有些时候我们需要设置id来对接label,datelist等，要注意的是id必须唯一！

4：多选框
<input type="checkbox" name="hobby"/>足球<br>//这里type="checkbox"，表示多选框，注意type的值要一致
<input type="checkbox" name="hobby"/>篮球   <br>
<input type="checkbox" name="hobby"/>乒乓球

5：定义按钮

```
<input type="button" onclick="alert('Hello World!')" value="Click Me!">
```

6：checked属性（默认选中选项）
<input type="checkbox" name="hobby" checked="checked"/>足球  <br>
<input type="checkbox" name="hobby" checked="false"/>篮球   <br>
<input type="checkbox" name="hobby" checked/>乒乓球

为了规范书写，一般添加checked="checked"就可以了。

checked 属性 与 <input type="checkbox"/> 或 <input type="radio"/> 一起配合使用。

7：disabled属性（禁止选中）
<input type="checkbox" name="course" disabled="disabled">影视鉴赏  <br>
<input type="checkbox" name="course">中国语言文学<br>
<input type="checkbox" name="course">心理学

为了规范书写，一般添加disabled="disabled"就可以了。

8：label标签（当点击用户该元素内的文本时，焦点会自动定位到与该标签绑定的表单元素上）
<label for="user">用户：</label>    
<input type="text" id="user" name="user"  /> <br><br>
<label for="pwd">密码：</label>
<input type="password" id="pwd" name="password"  />

注意：==这里是label中for的值和input里边的id值相同==！

9：下拉列表

```	html
<select>
    <option value="apple">苹果</option>
    <option value="banana">香蕉</option>
    <option value="pear" selected="selected">梨</option>
    <option value="apple">菠萝</option>
</select>
```

其中如果要指定某一个值为默认显示，添加selected="selected"即可

还有另外一种下拉列表的html标签

```html
<form action="action_page.php">
<input list="browsers">
<datalist id="browsers">
   <option value="Internet Explorer">
   <option value="Firefox">
   <option value="Chrome">
   <option value="Opera">
   <option value="Safari">
</datalist> 
</form>
```

使用该方法是要注意要设置input，并且input里面的list值要和datalist里面的id值要一致。



10：文本域
个人描述：<textarea maxlength="10" cols="" rows=""></textarea>//其中maxlength控制最大输入值,需要设置宽高才会显示。

11:文本上传域

<input type="file" name="">

12：提交按钮
<input type="submit" value="提交按钮"/>

13：重置表单内容

<input type="reset" value="重置">

14:我们可以使用fieldset来美化表单，使用该标签会自动给该表单添加一个外边框，需要配合legend来使用，使用方法只需要紧接着form下面使用该标签包裹所有的表单原件即可：

exp:

```html
<form action="action_page.php">
<fieldset>
<legend>Personal information:</legend>
First name:<br>
<input type="text" name="firstname" value="Mickey">
<br>
Last name:<br>
<input type="text" name="lastname" value="Mouse">
<br><br>
    <input type="submit" value="Submit"></fieldset>
</form> 
```

此外，Input的type还有许多其它的值可供我们选择，比如email,search,url,date,月份，年份选择表等，还有其它表单元素的属性比如设置输入框的内容最大长度等，但是这一些的使用频率并不是非常的高，如果有需要可以进入：

[https://www.w3school.com.cn/html/html_form_attributes.asp]()







> **补充**

1:article属性是HTML5的一个新属性，该标签定义独立的内容，定义的内容本身必须有意义且必须是独立于文档的其余部分

2:section标签定义了文档的某一个区域，比如章节1，头部，底部或者文档的其他区域

3:空格的表示法：` &nbsp;`

4:<main>标签规定文档的主要内容，在一个文档中它不应该出现一个以上的<main>元素，它不能是<article>,<footer>,<header>或<nav>的后代





<hr style="height:"3px">

==HTML并不是一门编程语言，而是一个标记语言，HTML5是HTML的其中一个最新的标准(规范)==

<hr style="height:3px;">







#### HTML5

> **常用新属性**

* `<article>`		定义页面独立的内容区域
* `<aside>`            定义页面的侧边栏内容
* `<footer>`          定义section或document的页脚
* `<header>`          定义了文档的头部区域
* `<section>`        定义文档中的节
* `<nav>`                定义导航链接部分
* <main>              规定文档的主要内容



> **多媒体元素**

1：音频

```html
<audio controls>
<source src="音频路径">
<source src="音频路径">/*备用*/
你的浏览器不支持audio元素
</audio>
```

2:视频

```html
<video controls>
<source src="音频路径">
<source src="音频路径">/*备用*/
你的浏览器不支持audio元素
</video>
```



> 音频和视频通用属性

* controls		使用该属性将会出现默认播放按键，可以通过javascript来个性化设置
* autoplay       使用该属性表示视频或者音频将会自动播放
* loop               设置视频或者音频循环播放
* poster            该属性在视频控件当中使用，里面插入图片路径来在视频还在加载时进行显示	



> **Canvas**

1：解释

是html5新属性中用来定义图形的一个块级容器

2：使用方法

* 首先在html区域当中使用<canvas>标签，接着我们可以内嵌或者style中为其设置宽度和高度，当然还有边框，别忘了给它加一个id属性

```html
<canvas id="mycanvas"
width="300" height="300"
style="border:1px solid #fff;">
</canvas>
```



* 接着使用JS来调用内嵌方法

```js
var c=document.getElementById("myCanvas");
var ctx=c.getContext("2d");
ctx.fillStyle="#FF0000";/*填充背景色为红色*/
ctx.fillRect(0,0,150,75);/*参数值表示在画布上画一个150x75的矩形，并且是从左上角开始(0,0)*/
```

3:一些示例

* 画线条

``` js
var c=document.getElementById("myCanvas");
var ctx=c.getContext("2d");
ctx.moveTo(0,0);/*定义线条开始坐标*/
ctx.lineTo(200,100);/*定义线条结束坐标*/
ctx.stroke();/*调用stroke()方法*/
```

* 画圆

```js
var c=document.getElementById("myCanvas");
var ctx=c.getContext("2d");
ctx.beginPath();
ctx.arc(95,50,40,0,2*Math.PI);/*分别控制水平位移，垂直位移，大小，弧度*/
ctx.stroke();
```



该属性通常是用来画类似于echarts的图表，更多画法在使用时建议百度





> **SVG**

通常可以用来画图标

* 画矩形

``` html
<!DOCTYPE html>
<html>
<body>

<svg xmlns="http://www.w3.org/2000/svg" version="1.1">
  <rect x="50" y="20" width="300" height="100" style="fill:rgb(0,0,255);stroke-width:1;stroke:rgb(0,0,0);fill-opacity:0.5;stroke-opacity:0.9" />
</svg>
 
</body>
</html>
```

说明

- rect 元素的 width 和 height 属性可定义矩形的高度和宽度
- style 属性用来定义 CSS 属性
- CSS 的 fill 属性定义矩形的填充颜色（rgb 值、颜色名或者十六进制值）
- CSS 的 stroke-width 属性定义矩形边框的宽度
- CSS 的 stroke 属性定义矩形边框的颜色
- x 属性定义矩形的左侧位置（例如，x="0" 定义矩形到浏览器窗口左侧的距离是 0px）
- y 属性定义矩形的顶端位置（例如，y="0" 定义矩形到浏览器窗口顶端的距离是 0px）



> WEB**存储**





























<hr style="height:5px;">










## CSS

-------------------------------------------------------------------------------------------------------
https://www.zhihu.com/question/24529373/answer/704041782



#### CSS-样式申明

1：外部样式：<link rel="stylesheet" href="houdunren.css" type="text/css">
2：嵌入样式：<style></style>
3:  内联样式： <h1 style="color:green;">houdunren.com</h1>
4：导入模式： <style>@import url("index.css");body{background:red;}</style>





#### CSS-选择器

> ==类选择器可以多个一样命名，而id选择器在一个文档当中只能是一个，不能重名！！！==



> **类选择器和元素选择器**

每一个类选择器都可以看作是一个根，它们的子根命名可以一样，exp: (.one.two)

1：.class             						exp:.intro                 	 选择所有class="intro"的元素

2：#id                						 exp:#firstname        	选择所有id="firstname"的元素

3：*                    						 exp:*                        	  选择所有的元素

4：element(元素/标签)              exp:p                            选择所有的P标签

5：element,element                 exp:div,p                      选择所有的div元素和p元素

6：element element                 exp:div p                      选择div元素内部的所有p元素==子孙都要==

7：element>element                exp:div>p                    选择父元素为div元素的所有p元素==只要儿子==（不包括孙级及以下元素）一个元素是另一个元素的子节点

8：element+element                exp:div+p               选择在div元素之后的所有p元素（==紧挨着的兄弟==）

9：element~element                exp:p~ul                  选择p元素后面的每个ul元素

element.classname(等同于 .classname);
示例：（在实际使用以上选择方法时，可以结合具体标签来精确定义）

```html
main article h2,main h1 {
    color: green;
}
<article>
		<h2 name="houdunren">houdunren.com</h2>
		<aside>
			<h2>houdunwang.com</h2>
		</aside>
	</article>
	<h2 name="hdcms.com">hdcms.com</h2>
	<h1>后盾人</h1>
</main>
```



​	



> **属性选择器**

1：为具有class属性的h1标签设置样式,可以类比出title等属性

```html
h1[class] {
    color: red;
}
<h1 class="container">houdunren.com</h1>
```



2：约束多个属性

```html
h1[class][id] {
    color: red;
}
<h1 class="container" id="only-id" >houdunren.com</h1>
```



3：具体属性值设置样式

```css
a[href="https://www.houdunren.com"] {
    color: green;
}
<a href="https://www.houdunren.com">后盾人</a>
<a href="">HDCMS</a>
```





4：^ 以指定值开头的元素（$ 以指定值结尾的元素/* 属性内部任何位置出现值的元素/~ 属性值中包含指定词汇的元素/| 以指定值开头或以属性连接破折号的元素）

```css
h2[name^="hdcms"] {
    color: red;
}
<h2 name="houdunren">houdunren.com</h2>

<h2 name="hdcms.com">hdcms.com</h2>
```





> **超链接使用伪类**

```css
a:link {//选择所有未被访问的链接
    color: red
}
a:visited {//选择所有已被访问的链接
    color: green
}
a:hover {//鼠标移动到元素上时
    color: blue
}
a:active {//点击正在发生时
    color: yellow
}
<a href="https://www.houdunren.com">后盾人</a>
```



以上也适用于input元素，此外，==input元素还有一个特殊的伪类：（：focus---选择获得焦点的input元素）==

我们可以使用这种方法结合outline:none来去掉input输入框的默认聚焦蓝色边框样式



> **：target**(用于控制具有锚点目标元素的样式)

```html
div {
	height: 900px;
}
div:target {
	color: red;
}
<a href="#hdcms">hdcms</a>`//同界面导航，设置id并使用href实现
<div id="hdcms">
	hdcms内容管理系统
</div>
```





> **：root**(根元素选择伪类即选择html)

```css
:root {
    font-size: 100px;
}
```





> :empty(对没有内容的元素进行选中和设置)使用该方法来对后台传输过来的空数据进行display:none隐藏处理

```html
:empty {
    border: solid 2px red;
}
<p></p>//该元素会被设置
<p> </p>//该元素不会被设置
```







==在使用结构伪类的时候一定要注意是否结合使用了空格的(子孙)后代选择器这一个细节==

> **结构伪类**

```html
<article>	
<span>houdunren.com</span> ------------A
	<aside>
		<span>houdunwang.com</span>--------------------B
		<span>hdcms.com</span>------------------------C
	</aside>
</article>
```



> **:first-child**选中AB

选择元素中span 标签并且是第一个

```css
article span:first-child {
    color: red;
}
```

==选择article中所有的子孙span，并且这一个span要满足是具有儿子的这一个身份，那么就可以使用该样式==





> **:first-of-type**选中AB

选择类型是span 的第一个元素

```css
article span:first-of-type {
    color: red;
}
```

==选择article里面的所有span标签，在同辈当中只要它是第一个span，那么就选中它，不在乎其它元素的位置==



:first-child与:first-of-type的区别：
:first-child选中的是指定元素必须是==其父级(相对父级)元素的第一个元素==，它会注重考虑父子关系和子孙关系；而:first-of-type不会考虑这个，他只会选择指定符合要求元素，==在兄弟同级当中不会考虑自己前面的元素是什么，只要在该属性标签前面没有出现过，那就入选==；并且如果该元素是多次重复出现，则会选择第一个





> **:last-child**[选中C]与**:last-of-type**[选中AC]的用法同上



> **:only-child**选择属于==其父元素(相对父级)的唯一子元素==的每一个元素[在上述实例当中B被选中]

==只要具备独生子的身份，那么就选中==



> **:only-of-type**选择属于其父元素唯一的元素的元素[在上述实例当中A被选中]

==即在同辈当中该标签的数量为1就被选中==



```html
	<span>houdunren.com</span> ------------A
	<aside>
		<span>houdunwang.com</span>--------------------B
		<span>hdcms.com</span>------------------------C
	</aside>
<span>hdcms.com</span>------------------------D
</article>
```



> **span:nth-child(n)**选择属于其父元素的第n个子元素并且第n个子元素就是该元素[在上述实例当中D被选中,n=2]





> **span:nth-of-type(n)）**选择属于其父元素下所有的span元素的第n个元素[在上述实例当中CD被选中，n=2]





> **隔列变色**

```css
  table tr>td:nth-child(2n+1) {
     background: green;
       color: white;
}
```



> **从第三个开始设置样式**

```css
table tr>td:nth-child(n+3) {
    background: rgb(128, 35, 2);
    color: white;
}
```





> **设置前三个元素**

```css
table tr>td:nth-child(-n+3) {
    background: rgb(128, 35, 2);
    color: white;
}
```





> **选择奇数单元格**

```css
table tr>td:nth-child(odd) {
    background: green;
    color: white;
}
```





> **选择偶数单元格**

```css
table tr>td:nth-child(even) {
    background: green;
    color: white;
}
```





> **:nth-last-child(n)**从最后一个元素开始获取

```css
table tr>td:nth-last-child(2n+1){
    background: green;
    color: white;
}
```





> **取最后两个元素**

```css
main>ul li:nth-last-child(-n+2) {
	color: red;
}
```







> **:nth-last-of-type(n)**从最后一个元素开始选择span标签



> **:not(selector)**排除第一个li元素

```css
ul li:not(:nth-child(1)) {
    background: red;
}
<ul>
  <li>houdunren.com</li>
  <li>hdcms.com</li>
  <li>后盾人</li>
</ul>
```







> **表单伪类**

* :enabled		input:enabled		选择每个启用的 input 元素
* :disabled		input:disabled		选择每个禁用的 input 元素
* :checked		input:checked		选择每个被选中的 input 元素
* :required		input:required		包含required属性的元素
* :optional		input:optional		不包含required属性的元素
* :valid		input:valid		验证通过的表单元素
* :invalid		input:invalid		验证不通过的表单

```html
input:valid {
    	border: solid 1px green;
}
input:invalid {
	border: solid 1px red;
}

<form>
<input type="email">
<button>保存</button>
</form>

```





​    

> **字符伪类**

* ::first-letter	p:first-letter	选择每个元素的首字母
* ::first-line		p:first-line	选择每个元素的首行
* ==::before		p:before		在每个元素的内容之前插入内容==
* ==::after		p:after		在每个元素的内容之后插入内容==



> CSS添加属性内容

```css
span::before {
    content: '⇰';
    color: red;
}
span::after {
    content: '⟲';//添加图标
    color: green;
}
...
<span>后盾人</span>
```





```css
div {
    border: solid 1px #ddd;
    width: 150px;
}
div>input[type="text"] {
    border: none;
    outline: none;
}
div>input[type="text"]+span:after {
    content: "\21AA";//添加字符以显示图标
    font-size: 14px;
    cursor: pointer;
}
<div>
	<input type="text"><span></span>
</div>
```



```css
h2::before {
	content: attr(title);//添加内容
}
<h2 title="后盾人">houdunren.com</h2>
```



在通常的项目开发当中，建议使用类选择器来设置页面的样式，同时我们也要注意选择器权重的叠加以及各种选择器的优先级对于样式的实际控制能否成功









#### 元素权重

1：通常情况下，在同一个元素当中同时设置了class和id之后，id的优先级（权限）大于class
2:相对于块级元素，行级元素的权重优先级最高
3：使用!important可以强制优先级来解决规则出现冲突的情况(建议尽量少的使用，应避免全局使用)
4：子元素会继承父元素设置的样式，该子元素并不是全部的样式（边框，高度并不会被继承，并且继承的规则没有权重）

5：==行内样式 > id选择器(id) > 类选择器(class)|属性选择器|伪类选择器 > 元素选择器 > *(通配符)==，优先级逐级减低,除非对其定义!important

6:对于一个元素的多重样式定义，样式的权重也会相应的叠加，在实际开发过程中建议使用less来写css样式来减少错误率









#### 文本控制

1：字体设置
可以设置多种字体，系统会自动依次查找，要注意的是应当使用通用字体，毕竟你使用的字体可能发布出去别人没有该字体

> **自定义字体**

```html
<style>
  @font-face {
  	font-family: "houdunren";
  	src: url("SourceHanSansSC-Light.otf") format("opentype"),
  	url("SourceHanSansSC-Heavy.otf") format("opentype");
  }
或者：（名字可以自定义，使用的字体要预先下载好）
@font-face{
    font-family: 'YaHei Consolas Hybrid';
	src:url(font/851CHIKARA-DZUYOKU_kanaA_004.ttf);
}
span {
  	font-family: 'houdunren';
  }
</style>
```





字体	格式
.otf	opentype
.woff	woff
.ttf	truetype
.eot	Embedded-opentype



> **字重定义**

font-weight(取值范围normal | bold | bolder | lighter | 100 ~900，其中normal对应400，700对应bold)



> **文本文号**

font-size
一般使用px，使用百分数时，表示的意思是子元素相对于父元素的大小，比如父元素是20px,子元素设置为200%即为你元素的两倍大小;此外，em单位等同于百分数单位



> **文本颜色**

使用color定义，color的值可以是字符串颜色（green）,也可以是十六进制网页颜色（#fff）,使用RGB颜色（color:rgba(38, 149, 162,.2);最后第四个参数管理的是颜色透明度，区间是0~1，可以不设置）



> **行高定义**

line-height(顾名思义，设置的是每一行文本的行距)



> **倾斜风格**

font-style:italic/normal


注意：以上样式可以组合定义，要注意先后关系



> **大小转换**

* 小号大写字母：font-variant:small-caps

* 字母大小写转换：(text-transform)
  * 首字母大写：text-transform:capitalize

  * 全部大写：text-transform:uppercase
  * 全部小写：text-transform:lowercase





> **文本线条**（text-decoration）

text-decoration:none(删除文本底端线条)
text-decoration:underline(添加下划线)
text-decoration:line-through(删除线)
text-decoration:overline(添加上划线)



> **阴影控制**（text-shadow）

exp:  text-shadow: rgba(13, 6, 89, 0.8) 3px 3px 5px;
参数顺序为：颜色，水平偏移，垂直偏移，模糊度



> **空白处理**（white-space）

pre	保留文本中的所有空白，类似使用 pre 标签
nowrap	禁止文本换行
pre-wrap	保留空白，保留换行符
pre-line	空白合并，保留换行符



> **文本溢出处理**

1:overflow-wrap:break-word
2:溢出添加...,需要将overflow设置在text-overflow前面

```css
h2 {
  width: 100px;
  border: solid 1px #ddd;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}
<h2>houdunren.com</h2>
```



##### 段落控制

> **文本缩进**（text-indent）

```html
p{
text-indent:2em;
}

```

​	

> **水平对齐**（text-align）

`text-align:left|right|center`

text-

> **设置行高**(==line-height==)

```html
p {
	text-indent: 2em;//设置文本缩进,要相对于父级元素居中，就要设置值和父级height相同
	line-height: 2em;//设置行高
}
```



> **垂直对齐**（vertical-align）

使用 vertical-align 用于定义内容的垂直对齐风格，包括middle | baseline | sub | super 等。
如果参数是bottom | top，表示的是相对于行框底部或者顶部对齐
此外还可以使用单位，比如20px等对齐方式



> **字符间距**

使用word-spacing与letter-spacing控制单词与字答间距

```css
h2 {
	word-spacing: 2em;/*对英文单词有效*/
	letter-spacing: 3em;/*对中文汉字有效*/
}
```



> **字间空格**

==&nbsp;==





> **排版方式**(wirting-mode)

horizontal-tb	水平方向自上而下的书写方式
vertical-rl		垂直方向自右而左的书写方式
vertical-lr		垂直方向内内容从上到下，水平方向从左到右





> **实现单行文本的溢出显示省略号**

实现方法一：

使用text-overflow:ellipsis属性，但需要配合使用overflow: hidden; white-space: nowrap这两个属性使用才能达到效果。

注意：

- 这里如果用了flex布局的话，text-overflow:ellipsis将会失效；
- 还有一个问题就是，关于 display:inline 和 display:hidden 一起使用 display:hideen 会失效的问题，因为display:inline,会让元素的宽度/高度失效,标签中有多少内容,标签就是多宽.所以当要将元素变为行内元素又要隐藏超出部分的内容时，可以用 display:inline-block 代替 display:inline；
- 再一个就是，display:inline-block 加上 overflow:hidden 会导致元素塌陷，解决办法有两种，1.浮动，然后清除浮动；2.给加了display属性的元素加vertical-align:bottom（个人推荐使用），或者vertical-align:top

如下：

overflow:hidden;

text-overflow:ellipsis;

white-space:nowrap;

效果：

![img](https://img2018.cnblogs.com/blog/1683377/201907/1683377-20190710141429256-902522704.png)

实现方法二：

```css
 font-size: 13px;
                height: 35px;
                width: 240px;
                display: -webkit-box; //必须结合的属性 ，将对象作为弹性伸缩盒子模型显示 。
                // -webkit-box-orient; //必须结合的属性 ，设置或检索伸缩盒对象的子元素的排列方式 。
                text-overflow: ellipsis; //，可以用来多行文本的情况下，用省略号“…”隐藏超出范围的文本 。
                overflow: hidden;
                text-overflow: ellipsis;
                display: -webkit-box;
                -webkit-line-clamp: 2;//超出第二行就用省略号代替
                -webkit-box-orient: vertical;
                margin-top: 0.6rem;
                margin-bottom: 0.6rem;
```











#### 阶段案例之下拉列表

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        /* 使用id或者类选择器会更加的迅速 */
        * {
            padding: 0;
            margin: 0;
            box-sizing: border-box;
        }

        /* 对body里面的元素进行按列居中对齐 */
        body {
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }

        /* 对main里面的元素进行等份按行排列 */
        main {
            border: 1px solid black;
            width: 500px;
            height: 500px;
            display: flex;
            justify-content: space-evenly;
        }

        section {
            /* 去除继承了父级的高度，而自定义宽度，避免hover伪类出现BUG */
            height: 30px;
            /* section的宽度由子级撑开 */
        }

        section:nth-child(1):first-child {
            width: 100px;
            height: 30px;
            border: 1px solid #aaa;
            border-radius: 3px;
            text-align: center;
            line-height: 30px;
            font-size: 13px;

        }

        section:nth-child(2) div:first-child {
            width: 100px;
            height: 30px;
            border: 1px solid #aaa;
            border-radius: 3px;
            text-align: center;
            line-height: 30px;
            font-size: 13px;

        }
 section:nth-child(2):hover #list2 {
            display: block;
        }
        
        section:nth-child(2) div:last-of-type {
            width: 100px;
            height: 90px;
            display: flex;
            justify-content: center;
            box-shadow: 1px 3px 5px #aaa;
            display: none;

        }

        section:nth-child(1) div:first-child:hover+#list {
            display: block;
        }


        section:nth-child(1) div:last-of-type {
            width: 100px;
            height: 90px;
            display: flex;
            justify-content: center;
            box-shadow: 1px 3px 5px #aaa;
            display: none;
        }

        ul {
            width: 100px;
            /* 让li元素继承父级ul的长度 */
        }

        li {
            list-style: none;
            text-align: center;
            height: 30px;
            /*让宽度继承ul父级*/
            line-height: 30px;
        }

        li:hover {
            background-color: #338833;
            color: white;
        }

    </style>
</head>

<body>
    <main>
        <!-- hover伪类只作用于button -->
        <section>
            <div>更多水果</div>

            <div id="list">
                <ul>
                    <li>苹果</li>
                    <li>香蕉</li>
                    <li>奇异果</li>
                </ul>
            </div>
        </section>

        <!-- 伪类选择器作用于按钮和整个按钮区域 -->
        <section>
            <div>更多手机</div>

            <div id="list2">
                <ul>
                    <li>苹果</li>
                    <li>华为</li>
                    <li>三星</li>
                </ul>
            </div>

        </section>
    </main>

</body>

</html>
```

> 案例总结

* 一定要弄清楚父子级之间的关系还有子级继承父级某一些特性的情况
* 我们可以==给每一个块级元素加border边框来查看该元素的作用域==







#### 阶段案例之滚动条设置

```html
<style>
      * {
        padding: 0;
        margin: 0;
      }
      body {
        width: 100vw;
        height: 100vh;
        display: grid;
        grid-template: repeat(12, 1fr) / repeat(12, 1fr);
      }
      #mydiv {
        grid-column: 4 / span 6;
        grid-row: 4 / span 4;
        /* border: 1px solid #aaa; */
        box-shadow: 1px 1px 4px #999999;
        font-size: 12px;
        padding: 10px;
        box-sizing: border-box;
        overflow: scroll;//对溢出div区域的内容设置滚动显示
        overflow-x: hidden;//隐藏掉底部即X轴的滚动栏区域部分
      }
      /* 设置滚动条样式 */
      ::-webkit-scrollbar {
        width: 4px;
        background-color: white;
        /* border: 1px solid black; */
      }
      /* 滚动槽 */
      ::-webkit-scrollbar-track {
        border-radius: 50px;
      }
      /* 滚动条 */
      ::-webkit-scrollbar-thumb {
        border-radius: 3rem;
        background-color: #ddd;
        width: 10px;
      }
      button {
        grid-column: 7 / span 1;
        grid-row: 10 / span 1;
        background-color: black;
        color: #fff;
        transform: translateX(-50%);
      }
    </style>
  </head>
  <body>
    <div id="mydiv"></div>
    <button>请求数据</button>
    </script>
  </body>
```



```css
 滚动条的设置
::-webkit-scrollbar 滚动条整体部分，可以设置宽度啥的
::-webkit-scrollbar-button 滚动条两端的按钮
::-webkit-scrollbar-track  外层轨道
::-webkit-scrollbar-track-piece  内层滚动槽
::-webkit-scrollbar-thumb 滚动的滑块
::-webkit-scrollbar-corner 边角
::-webkit-resizer 定义右下角拖动块的样式
```



css对于滚动条的设置是使用伪类来进行操纵的，可类比输入框的提示文字(placeholder)









#### 盒子模型

以内容（content）为中心

> 内容与边框之间的范围

使用padding，也可以使用padding-left,padding-top,padding-right,padding-bottom；



> 边框的管理

使用border，也可以使用border-left,border-top,border-right,border-bottom



> 边框与周围区域的管理

使用margin,也可以使用margin-top,margin-left,margin-right,margin-bottom



> **居中设置**

使用`margin-left:auto；margin-right:auto`来实现



> 设置宽度与高度包括内边距与边框

使用box-sizing:border-box;

* 如果该元素设置了该属性之后，它的子节点设置的width和height就会包含它设置的border和padding;
* 如果该元素溢出到父元素之外，在该元素使用这一个属性可以让该元素回归



> 边框设计可以使用border-style

none	定义无边框。
dotted	定义点状边框。在大多数浏览器中呈现为实线。
dashed	定义虚线。在大多数浏览器中呈现为实线。
solid	定义实线。
double	定义双线。双线的宽度等于 border-width 的值。
groove	定义 3D 凹槽边框。其效果取决于 border-color 的值。
ridge	定义 3D 垄状边框。其效果取决于 border-color 的值。
inset	定义 3D inset 边框。其效果取决于 border-color 的值。
outset	定义 3D outset 边框。其效果取决于 border-color 的值。

单独设置边框样式：
border-top-style		顶边
border-right-style		右边
border-bottom-style	下边
border-left-style		左边
border-style		四边



> 边框宽度设置

border-top-width		顶边
border-right-width		右边
border-bottom-width	下边
border-left-width		左边
border-width                           四边



> 边框颜色设置

border-top-color		顶边
border-right-color		右边
border-bottom-color	下边
border-left-color		左边
border-color		四边



> 圆角边框：（border-radius）

border-top-left-radius	上左
border-top-right-radius	上右
border-bottom-left-radius	下左
border-bottom-right-radius	下右

定义不同边：border-radius: 10px 30px 50px 100px;

==通过边框绘制圆：border-radius:50%;前提是要先给需要设置成圆角的元素设置宽高==

==可以利用该分解方法来画半圆：border：35px 35px 0 0;画了一个没有下半个圆的半圆形==



行元素绘制圆角：
em {
	border-radius: 50%;
	border-bottom: solid 2px red;
}



> **轮廓线设置**（outline），==通常用来设置表单input的边框样式==

* outline-style: double;(设置线框样式)

* ouline-width：10px(线框设置)

* outline-color:red;(线条颜色)

* 组合定义：outline: red solid 2px;

* 去除表单轮廓线：`input:focus{outline:none;}`
  

> **控制显示隐藏**（display）

可以使用的参数如下：
none              	隐藏元素（不保留隐藏后原来内容的空间）
block             	显示为块元素（行转块元素）
inline             	显示为行元素，不能设置宽/高（块转为行元素）
inline-block              行级块元素，允许设置宽/高（行级块使用）

==要注意区分的是当我们对行内元素使用display:inline-block时，该元素就可以设置宽高，但是它不会换行==



> visibility: hidden;（控制元素的显示隐藏，==在隐藏后空间位也保留==）





> **溢出控制**(overflow)

可以使用的参数如下：
hidden		溢出内容隐藏
scroll		显示滚动条（有些浏览器会一直显示，有些在滚动时显示）
auto		根据内容自动处理滚动条

==我们可以给定一个块级元素的宽高，接着对该块级元素添加一个子级块级元素，这样，子级无论怎样大小，在设置了overflow:scroll后，都是在父级元素里面进行显示的；==





> 单行文本溢出

```css
div {
  width: 400px;
  height: 100px;
  border: solid 2px #ddd;
  padding: 20px;
  overflow: hidden;//隐藏溢出内容
  text-overflow: ellipsis;
  white-space: nowrap;//禁止文本换行
}
```



> 多行文本溢出控制

```css
div {
  width: 200px;
  overflow: hidden;
  display: -webkit-box;
  -webkit-line-clamp: 3;
  -webkit-box-orient: vertical;
}
```







> 尺寸定义

width						宽度
height					   高度
min-width			    最小宽度
min-height	           最小高度
max-width	            最大宽度
max-height	           最大高度

> fill-available	撑满可用的空间

```css
span {
            background: #e67e22;
            display: inline-block;
            width: -webkit-fill-available;
            height: -webkit-fill-available;
        }
```



> fit-content	根据内容适应尺寸

```css
h2 {
            text-align: center;
            background: #f1c40f;
            width: fit-content;
            margin: auto;
        }
```





> min-content （max-content）            将容器尺寸按最小(大)元素宽度设置

```css
 main {
            width: min-content;
            margin: auto;
        }
```



最大最小建议在已经定义了确定长度宽度的前提内部下面使用，建议使用百分比



> **行级元素和块级元素的区分**

1：在一般文本流和文档流当中，块级元素会自动换行，而行级元素不会

2：块级元素可以设置宽高而行级元素不可以















#### 背景样式

> **背景颜色**

background-color / background



> **背景图片**

background-image: url(icon-s.jpg);



> **背景裁剪**（background-clip）

* border-box------------------包括边框
* padding-box----------------不包含边框，包含内边距
* content-box-----------------内容区域



> **背景重复**（background-repeat）

* repeat-------------------水平，垂直重复
* repeat-x -------------------水平重复
* repeat-y -------------------垂直重复
* ==no-repeat-------------------不重复==
* space-------------------背景图片对称均匀分布



> **背景滚动**（background-attachment）

* scroll----------------背景滚动
* ==fixed----------------背景固定==



> **背景位置**（background-position）

* left---------------------左对齐
* right---------------------右对齐
* center---------------------居中对齐
* top---------------------顶端对齐
* bottom---------------------底端对齐

我们也可以设置具体数值并结合设置的图片大小来选定图片的某一个区域

```css
div {
            background-image: url('./elf.png');
            background-repeat: no-repeat;
            width: 152px;
            height: 24px;
            background-position: -4px -52px;/*分别表示水平方向和竖直方向的偏移*/
        }

```







> **背景尺寸**（background-size）

* cover-------------------背景完全覆盖，可能会有背景溢出
* contain-----------------图片不溢出，但是会漏出部分空白区域



> **多个背景**

* 后定义的背景置于底层
  `background-image: url(xj-small.png), url(bg.png);`

* 多属性定义

  ```css
  background-image: url(xj-small.png), url(bg.png);
  background-repeat: no-repeat;
  background-position: top left, right bottom;
  ```

* 可以一次定义多个背景图片及其样式

```css
background: url(xj-small.png) left 50% no-repeat,
                url(bg.png) right 100% no-repeat red;
```





> **==盒子阴影==**（box-shadow）

```css
box-shadow:10px 10px 5px rgba(100,100,100,0.5);
参数对应的含义分别为：水平偏移，垂直偏移，模糊度，颜色
```



`box-shadow: 23px 0 0 currentColor, 53px 0 0 currentColor, 83px 0 0 currentColor;`
/*某一个元素的阴影可以分离复制出多个，其中currentColor的意思是继承它主体的颜色*/



> **颜色渐变**

> 线性渐变（以直线的扩散规则）

* 渐变一般在背景颜色中使用
  `background:linear-gradietnt(red,green);`

* 渐变角度
  `background:linear-gradient(30deg,red,green);`

* 向右(左)渐变
  `background:linear-gradient(to right（left）,red,green);`

* 向左上（右下渐变）
  `background:linear-gradient(to top left(right bottom)，red,green);`

* 设置多个颜色
  `background: linear-gradient(red, rgb(0, 0, 200), green, rgba(122, 211, 100, 0));`



> 径向渐变(以圆的扩散规则)

* 设置渐变
  `background:radial-gradient(red,blue,green);`

* 设置渐变宽度与高度
  `background:radial-gradient(100px 200px, red,blue,green);`

* 左下渐变

`background: radial-gradient(at bottom left, red, blue);`

* 右下渐变

`background: radial-gradient(at bottom right, red, blue);`

* 左侧向中心渐变

`background: radial-gradient(at center left, red, blue);`

* 底部向中心渐变

`background: radial-gradient(at 50% 100%, red, blue);`





> 标识位

颜色未指定标识时，颜色会平均分布。
红色与蓝色在50%gc 60%间发生激变.

`background: linear-gradient(45deg, red 50%, blue 0%);`

标识位相同时将没有过渡效果

`background: linear-gradient(45deg, red 0,red 50%, blue 50%);`

实例：
1：绘制小太阳

```css
width: 150px;
height: 150px;
background: radial-gradient(red 0, yellow 30%, black 60%, black 100%);
```



2：下例定义从0到25为蓝色,25px到50px的红色，并进行重复后产生渐变的进度条。
`background: repeating-linear-gradient(90deg, blue, 25px, yellow 25px, 25px, red 50px);`



3：光圈

```css
width: 200px;
height: 200px;
background: repeating-radial-gradient(100px 100px, red 0%, yellow 40%, black 60%, black 200%);
```















#### 数据样式

> **表格**

* 表格标题

  caption-side(值可为top|bottom)



* 内容对齐

  水平对齐：text-align:center
  垂直对齐：vertical-align(top顶对齐|middle垂直居中|bottom底部对齐)

  

* 边框间距

`border-spacing:50px 10px;`(设置间距上下10px,左右50px)



* 边框合并``border-collapse:collapse`



* 隐藏单元格`empty-cells:hide;`



* 无边框表格`border:none;`







> **列表**

* 使用list-style-type来设置列表样式，规则是继承的，所以在ul标签上设置即可，可以选择的值如下：

  none				无标记。
  disc				默认。标记是实心圆。
  circle				标记是空心圆。
  square				标记是实心方块。
  decimal				标记是数字。
  decimal-leading-zero		0开头的数字标记。(01, 02, 03, 等。)
  lower-roman			小写罗马数字(i, ii, iii, iv, v, 等。)
  upper-roman			大写罗马数字(I, II, III, IV, V, 等。)
  lower-alpha			小写英文字母The marker is lower-alpha (a, b, c, d, e, 等。)
  upper-alpha			大写英文字母The marker is upper-alpha (A, B, C, D, E, 等。)
  lower-greek			小写希腊字母(alpha, beta, gamma, 等。)
  lower-latin			小写拉丁字母(a, b, c, d, e, 等。)
  upper-latin			大写拉丁字母(A, B, C, D, E, 等。)
  hebrew				传统的希伯来编号方式
  armenian				传统的亚美尼亚编号方式
  georgian				传统的乔治亚编号方式(an, ban, gan, 等。)
  cjk-ideographic			简单的表意数字
  hiragana				标记是：a, i, u, e, o, ka, ki, 等。（日文片假名）
  katakana				标记是：A, I, U, E, O, KA, KI, 等。（日文片假名）
  hiragana-iroha			标记是：i, ro, ha, ni, ho, he, to, 等。（日文片假名）
  katakana-iroha			标记是：I, RO, HA, NI, HO, HE, TO, 等。（日文片假名）

当然也可以自定义样式：

```css
ul li {
  /* list-style-image: url(xj-small.png);//自定义图片为列表样式
  list-style-image: radial-gradient(10px 10px, red, black); */
   list-style-image: linear-gradient(45deg, red, black);//多色渐变
}
```





 



* 符号位置

  `list-style-position:inside（outside）`控制符号显示在内容外部还是内部


  ​	当然以上两个样式可以统一定义：list-style:circle inside;

```css
ul li {
  background: url(xj-small.png) no-repeat 0 6px;
  background-size: 10px 10px;
  list-style-position: inside;
  list-style: none;
  text-indent: 15px;
}
```





```css
<style>
        ul {
            list-style-type: none;
        }
     ul li {
        background-image: url(xj-small.png), url(houdunren.jpg);
        background-repeat: no-repeat, repeat;
        background-size: 10px 10px, 100%;
        background-position: 5px 7px, 0 0;
        text-indent: 20px;
        border-bottom: solid 1px #ddd;
        margin-bottom: 10px;
        padding-bottom: 5px;

    }   
</style>
```





​    



> **追加内容**

==我们可以使用css来给html上灵活添加内容==使用伪类::before向前添加内容，使用::after向后面添加内容

```css
a::after {
  content: " (坚持努力) ";
}
```



提取属性值

```css
<style>
  a::after {
    content: attr(href);
  }
</style>
<a href="houdunren.com">后盾人</a>
```















#### 浮动布局

> float（可选参数：left | right | none）

1.在网站开发过程中需要一行排列多个元素，使用浮动可以方便实现
通常对每一个元素都设置浮动之后，元素会根据先后关系按行来依次排列；

2.元素在设置了浮动之后就会变成块元素，如span，所以设置了浮动的元素可以设置宽高（width,heigth）

浮动影响的是跟在他后面的元素，对元素设置浮动它就有浮动特性（按行排列）

> 清除浮动，让父元素可以继承子元素的宽高的两种方法

clear,可选参数如下：

left			左边远离浮动元素
right			右连远离浮动元素
==both			左右都远离浮动元素==

1.after
使用::after伪类为父元素添加后标签，实现清除浮动影响

==之所以这样做是因为当我们使用浮动来布局的时候，对于要控制的元素，我们首先需要给它添加一个父元素框，但是我们添加的这一个父元素的宽高不会感应到子元素的宽高而自己自适应调整宽高，这时我们就需要设置另外一个不显示在页面的元素，并且清除掉它的浮动，并设置它为块级元素，让父元素感知到子元素的宽高，从而达到自适应的目的；==

```css
main::after{ 
content:"";
display:block;/*转换为块级元素*/
clear:both;/*清除浮动*/
}
```

2.overflow（hidden | auto）
子元素使用浮动后不占用空间，这时父元素高度将为0，通过添加父元素并设置overflow属性可以清除浮动；

==触发BFC机制==



使用浮动来布局页面的时候，我们应当划分区域，==把各组件部分划分为多组==，这一些组之间可以是兄弟关系，也可以是父子关系，依据的是浮动元素只和父级元素有关联，从而达到相对性布局；

> 形状浮动（shape-outside），可选参数如下：

margin-box	外边距环绕
padding-box	内边距环绕
border-box	边线环绕
content-box	内容环绕



1.显示区域设置（clip-path）,可选参数如下：
circle	圆形
ellipse	椭圆
polygon	多边形

exp:

clip-path: circle(50% at center);/* 圆形*/


clip-path: ellipse(50% 80% at 100% 0);/*椭圆*/

clip-path: polygon(50% 0, 100% 100%, 0 100%);/*多边形*/



2.环绕模式：

*  shape-outside: circle(50%) padding-box;

*  shape-outside: ellipse(80px 70px) padding-box;

* shape-outside: url(xj.png);

* clip-path: polygon(50px 0px, 0 100px, 100px 100px);
      shape-outside: polygon(50px 0px, 0 100px, 100px 100px);

  

==当我们要设置一个父元素的高度的时候，一个比较好的做法是通过设置子元素的上下padding来顶父元素的高度，这样使用效率更高，此外，当我们在页面上使用了一个块级元素的时候，只设置它的高度，一般情况下宽度width就会自适应全屏幕的宽度，这是因为有些没有设置的属性会自动继承父级元素属性==

==margin:0 auto和width要配合使用才可以达到居中的效果==





#### 定位布局



使用position,有五个可选参数：

> static	默认形为，参考文档流

> **relative**	相对定位

相对定位是==相对于元素原来的位置==控制，当元素发生位置偏移时，原位置留白，可以使用left,top,bottom以及right来对其进行操作；该方式的一个好处就是要移动某个元素的时候，不会出现把它相邻的元素顶开



> **absolute**	绝对定位

绝对定位不受文档流影响，就像漂浮在页面中的精灵，绝对定位元素拥有行内块特性；
==要注意的是：如果父级元素设置了relative | fixed |  sticky,绝对定位子元素将参照父元素的位置以及划定的区域进行定位==
如果没有为定位元素设置偏移，将受父元素padding等属性影响



> **fixed**	固定定位

设置该属性之后，==元素相对于视窗固定定位在某一个位置==，固定定位元素不会在滚动时改变位置；



> **sticky**    粘性定位

对原来的元素进行覆盖(假设有几段文字，这几段文字由标题和段落构成，对标题使用粘性定位时，当我们在滑动浏览每一个段落的时候，标题就会进行悬浮显示，直到对应的该段消失；对于h1和p我们可以分开在多个section也可以放在同一个article当中，两者体现出来的效果是一样的)



> **居中定位设置**：

position:absolute;
left:50%;
top:50%;



> **纵向重叠**

如果元素重叠在一起，可以使用z-index控制元素的上下层级，==数值越大越在上面；==

要注意的是==父级子元素设置z-index没有意义==，因为子元素永远在父元素的上面，因此z-index应当在同级元素中设置

==要设置z-index的前提是要对该元素设置position==



> **补充**

* 当一个块级元素它的==父级元素使用了position==(值可以是relative或者absolute),那么如果==该块级元素没有设置宽高的情况下==再对其使用position进行定位的话，那么就相当于是在给其添加宽高等尺寸，比如对该元素设置：

  ```css
  position:absoulute;
  left:0;
  top:0;
  bottom:0;
  right:0;
  ```

  作用是让该元素填满整个父元素

  

* 在定位布局当中，最基本的布局就是基本文本流

* 一般情况下，对一个有宽高的块级元素设置了宽高之后在对其进行position:absolute；那么它的移动是按照它的左上角为中心来进行的，这时，可以尝试用margin-top/margin-left设置负值来进行调整





#### 弹性布局

Flex 的意思是--“弹性布局”,可以轻松控制元素排列，对齐，顺序的控制
使用弹性盒模型可以让元素在不同的尺寸终端控制尺寸



##### 1：声明：

display:flex/*随屏幕伸缩*/声明为块级（在哪个元素里面声明，该元素就变成了一个弹性盒子）
display:inline-flex/*固定了里面元素宽度，不会随着屏幕尺寸改变而改变*/声明为内联级



##### 2：控制盒子元素排列的方向（flex-direction）

row			从左到右水平排列元素（默认值）
row-reverse		从右向左排列元素
column			从上到下垂直排列元素
column-reverse		从下到上垂直排列元素

##### 3:控制当页面变化时元素的排列（flex-wrap）

nowrap		元素不拆行或不拆列（默认值）
wrap		容器元素在必要的时候拆行或拆列。
wrap-reverse	容器元素在必要的时候拆行或拆列，但是以相反的顺序





##### 4:flex-flow是以上两种设置方法的组合简写：

exp:flex-flow: row-reverse wrap-reverse;

###### 4.1水平排列

flex-flow:row wrap

flex-flow:row-reverse wrap-reverse

###### 4.2垂直排列

flex-flow:column wrap





##### 5:控制元素在主轴的排列方式（原生屏幕)（justify-content）注意，它控制的是主轴！（取决于flex-flow的值）

flex-start----元素紧靠主轴起点
flex-end-----元素紧靠主轴终点
center------ 元素从弹性容器中心开始
space-between----第一个元素靠起点，最后一个元素靠终点，余下元素平均分配空间
space-around-----每个元素两侧的空隔相等，此时项目之间的间隔比项目与边框的间隔大一倍
space-evenly------元素之间距离平均分配





##### 6：控制容器元素（所有）在交叉轴的排列方式（align-items）注意：它控制的是交叉轴！

stretch	元素被拉伸以适应容器（默认值）
center	元素位于容器的中心
flex-start	元素位于容器的交叉轴开头（首部）
flex-end	元素位于容器的交叉轴结尾（底端)


注意：如果设置了 width | height | min-height | min-width | max-width | max-height ，将影响stretch 的结果，因为 stretch 优先级高于宽高设置。



对元素进行居中：flex-flow:row;justfy-content:center;align-items:center;





##### 7：align-content

只适用于多行显示的弹性容器，它的作用是当flex容器在交叉轴上有多余空间时，对元素对齐处理
stretch		将空间平均分配给元素
flex-start		元素紧靠主轴起点
flex-end		元素紧靠主轴终点
center		元素从弹性容器中心开始
space-between	第一个元素靠起点，最后一个元素靠终点，余下元素平均分配空间
space-around	每个元素两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍
space-evenly	元素间距离平均分配





##### 8：弹性元素（文本也是弹性元素，也可以使用弹性布局）

定义：放在容器盒子中的元素即为容器元素
1：不能使用float与clear规则

2：弹性元素均为块元素（可设置宽高）

3：绝对定位的弹性元素不参与弹性布局

4：==在对p标签设置display:flex;justfy-content:center;align-item:center时，其实起作用的是它的子元素TEXT,对P标签设置了宽高之后，TEXT就会居中==



##### 9：align-self

用于控制单个元素在交叉轴上的排列方式
stretch	将空间平均分配给元素
flex-start	元素紧靠主轴起点
flex-end	元素紧靠主轴终点
center	元素从弹性容器中心开始



##### 10：flex-grow

用于将弹性盒子的可用空间分配给弹性元素，值可以为整数或者小数(注意这里的可用空间是指没有被占用的空间，而且它正对的是一个具体的元素)

```css
article div:nth-of-type(1) {
    width: 100px;
    flex-grow: 1;
  }
  article div:nth-of-type(2) {
    width: 100px;
    flex-grow: 3;
  }
  article div:nth-of-type(3) {
    width: 300px;
    flex-grow: 6;
  }
```



上面例子为三个DIV 弹性元素设置了1、3、6 ，即宽度分成10等份，第三个元素所占宽度为(宽度/(1+3+6)) X 6。

注意：如果我们对于一个已经设定了弹性区域设置flex-grow:1;那么这一个弹性区域会自动把里面的空间全部撑满；

##### 11:flex-shrink

与flex-grow相反，该方法是在弹性盒子装不下元素时定义的缩小值

下例在600宽的弹性盒子中放了 1000 宽的弹性元素。并为最后两个元素设置了缩放，最后一个元素的缩放比例为 500 -( ( (1000-600) / (100X1+400x3+500X6) ) x 3 ) X 500 = 220.9，计算公式说明如下：

缩小比例 = 不足的空间 / (元素 1 宽度 x 缩小比例) + (元素 2 宽度 x 缩小比例) ...
最终尺寸 = 元素三宽度 - (缩小比例 x  元素 3 的宽度) X 元素

``` css
article div:nth-child(1) {
        flex-shrink: 0;
    }
    article div:nth-child(2) {
        flex-shrink: 1;
    }
    article div:nth-child(3) {
        flex-shrink: 3;
    }
```





##### 12:flex-basis(定义基础尺寸)

flex-basis 属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。



注意：flex是flex-grow、flex-shrink 、flex-basis缩写组合。

建议使用 flex 而不要单独使用 flex-grow / flew-shrink / flex-basis 。
exp: flex: 1 0 100px;



##### 13:order

用于控制弹性元素的位置，默认值为0，数值越小越在前面，可以为负数或整数
例如有四个div元素都是按照html既定顺序排列，通过使用对每个div区域设置order数值就可以改变它们的上下排列顺序！

文本节点（span等）也在弹性布局操作范围内，绝对定位的弹性元素不参与弹性布局



##### 14：自动空间

在弹性布局中对元素使用margin-right:auto 等形式可以自动撑满空间。
下例为第一个ul设置 margin-right:auto 表示右侧空间自动撑满，第二个ul靠近父元素右边界。



![](C:\Users\啊啊啊\Desktop\批注 2020-03-03 223419.png)

```html
<!DOCTYPE HTML>    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        * {
            padding: 0;
            margin: 0;
        }
        .container {
        width: 1200px;
        margin: 0 auto;
    }

    nav {
        display: flex;
        border: solid 1px green;
        margin-top: 20px;
        align-items: center;
        height: 60px;
        box-shadow: 0 0 5px rgba(0, 0, 0, .2);
        background: #f3f3f3;
    }

    ul {
        list-style: none;
    }

    ul:nth-child(1) {
        display: flex;
        align-items: center;
        margin-right: auto;
    }

    ul:nth-child(1)>li {
        margin: 0 10px;
    }

    ul:nth-child(2)>li {
        width: 50px;
        height: 50px;
        border-radius: 50%;
        background: #9b59b6;
    }
</style>
</head>
<body>
    <div class="container">
        <nav>
            <ul>
                <li>houdunren</li>
                <li>视频教程</li>
                <li>每晚直播</li>
                <li>在线文档</li>
            </ul>
            <ul>
                <li>
                </li>
            </ul>
        </nav>
    </div>
</body>
<doctype>
```






弹性布局里面的的每一个元素既可以是弹性元素，也可以是弹性容器！

注意：
要找到真正的爸爸（直接父元素），即使用弹性布局的对象，必须要包含所有需要操控的元素
exp:
正确示范：

```html
section {
            display: flex;
        }
<body>
    <main>
        <section>
            <div><img src="../炫酷特效源码/image/v2-06035b75b25f0d19d7b8efa04c6dec07_r.jpg" alt=""></div>
            <div><img src="../炫酷特效源码/image/v2-11246fc02f37570e7f26154ea9082847_r.jpg" alt=""></div>
            <div><img src="../炫酷特效源码/image/v2-a0620b47fcea13878cce382659529959_r.jpg" alt=""></div>
            <div><img src="../炫酷特效源码/image/v2-fefde43aecf0174852a075f56cb3c9ea_r.jpg" alt=""></div>
        </section>
    </main>
    </body>
```





错误示范：（不起任何作用）

```html
div {
            display: flex;
        }
<body>
    <main>
        <section>
            <div><img src="../炫酷特效源码/image/v2-06035b75b25f0d19d7b8efa04c6dec07_r.jpg" alt=""></div>
            <div><img src="../炫酷特效源码/image/v2-11246fc02f37570e7f26154ea9082847_r.jpg" alt=""></div>
            <div><img src="../炫酷特效源码/image/v2-a0620b47fcea13878cce382659529959_r.jpg" alt=""></div>
            <div><img src="../炫酷特效源码/image/v2-fefde43aecf0174852a075f56cb3c9ea_r.jpg" alt=""></div>
        </section>
    </main>
    </body>
```











#### 栅格布局

（更加注重于对于整体的布局，而对于元素关心较少）

CSS网格布局是CSS中最强大的布局系统，这是一个二维系统，它可以同时处理列和行
栅格系统与FLEX弹性布局相似，都是由父容器包含多个项目元素的使用

1：块级容器声明
display:grid;

2:行级容器声明(少用)
display:inline-grid;

3:划分行列
与表格（table）类似；
grid-template-rows------划分行
grid-template-columns----划分列
exp:(划分为两行四列)
grid-template-rows: 50% 50%;（画表格的第一种方法）
grid-template-columns: 25% 25% 25% 25%;


只是划分了一个定义好了的容器，对定义了栅格布局元素里面的元素智能填充
可以使用百分比，也可以使用px等，使用百分比将会相对于父级元素的大小进行按比例划分


4：重复设置
以上设置也可以使用repeat统一设置值,第一个参数为重复数量，第二个参数为重复值
exp:
原：grid-template-rows: 50% 50%;
       grid-template-columns: 25% 25% 25% 25%;

后：grid-template-rows:repeat(2,50%);
       grid-template-columns:repeat(4,25%);



5:自动填充（根据容器尺寸，自动填充）
grid-template-rows: repeat(auto-fill, 100px);（画表格的第二种方法）
grid-template-columns: repeat(auto-fill, 100px);



6：比例划分（使用fr单位按份划分）
exp:
grid-template-rows:1fr 2fr;/*划分为两行，按照1：2来划分*/（画表格的第三种方法）
grid-template-columns:100px 1fr 2fr;/*划分为三列*/


重复定义：
grid-template-rows:repeat(2,1fr);/*1fr 1fr*/
grid-template-columns:repeat(2,1fr 2fr)/*相当于1fr 2fr 1fr 2fr*/


对于行和列的定义可以组合定义（用‘ / ’来划分）
grid-template: 100px 1fr / 50px 1fr



7：minmax
使用该方法可以设置取值范围（不会随着页面的增大减小而无限增大或者减小）
exp:
grid-template-rows:100px minmax(100px,1fr);/*第二行的行高在最小100px~最大1fr间取值*/


8：row-gap(column-gap)
使用该方法可以设置行间距(列间距)
exp:
grid-template-rows:repeat(2 1fr);
grid-template-columns:repeat(3,1fr);
row-gap:30px;


组合定义
使用gap可以一次定义行，列间距，如果间距一样可以设置一个值，使用了该方法就会自动对行列间距进行管理
gap: 20px 10px;/*行间距为20px , 列间距为10px*/

gap:20px;/*行列间距都是20px*/




栅格布局设置了行列宽度之后，可以直接使用边线默认编号（1，2，3 . . .）来作为名字来进行调用；
9:独立命名
为每个栅格独立命名来进行调用
9.1步骤一：在行列划分宽度区域命名
exp:
 display: grid;
        grid-template-rows: [r1-start] 100px [r1-end r2-start] 100px [r2-end r3-start] 100px [r3-end];

        grid-template-columns: [c1-start] 100px [c1-end c2-start] 100px [c2-start c3-start] 100px [c3-end];


步骤二：调用，并为该元素设置位置（r2-start和r1-end重叠选择两者均可）
	grid-row-start: r1-end;
        	grid-row-end: r2-start;
        	grid-column-start: c1-end;
        	grid-column-end: c2-start;



9.2自动命名
对于重复设置的栅格系统会自动命名，使用时使用c1,c2的方式定位栅格
步骤一：在行列划分宽度区域命名
grid-template-rows: repeat(3, [r-start] 100px [r-end]);
grid-template-columns: repeat(3, [c-start] 100px [c-end]);

步骤二：调用，并为该元素设置位置
grid-row-start: r-start 2;（从编号为2的行开始）
grid-column-start: c-start 2;
grid-row-end: r-start 2;
grid-column-end: c-end 2;




10：元素定位
grid-row-start		行开始栅格线
grid-row-end		行结束栅格线
grid-column-start		列开始栅格线
gird-column-end		列结束栅格线



注意：弹性盒模型和栅格系统可以结合使用


11：根据偏移量定位（也就是该元素占多少个位置，以默认位置作为起始）
div:first-child {
        grid-row-start: 2;
        grid-column-start: 2;
        grid-row-end: span 1;（编号加1）
        grid-column-end: span 1;
    }

或者（简写）：
div:nth-child(2){
    grid-row:1/span 2;
    gird-column:2/span 2;
}
如果知道该元素的默认边线，那么可以直接span即可；


12：gird-area
这是对上面四个定位元素的组合
语法结构：grid-row-start/grid-column-start/grid-row-end/grid-column-end。
exp:
grid-template: repeat(3, 1fr)/repeat(3, 1fr);

grid-area: 2/2/3/3;



12.2对每一个区域（单元格）进行命名
exp:
        grid-template-rows: 80px 1fr 50px;(1fr表示自动填充)
        grid-template-columns: 100px 1fr 50px 60px;
        grid-template-areas: "header header header header"
            		          "nav main main aside"
                                           "footer footer footer footer";

header {
        background: #2EC56C;
        grid-area: header;（把所有名字为header的单元格全部占满）
    }

    nav {
        background: #E1732C;
        grid-area: nav;
    }
    
    aside {
        grid-area: aside;
        background: #EEBC31;
    }
    
    footer {
        grid-area: footer;
        background: #904FA9;
    }











13:栅格对齐（参数参照弹性布局）（元素和容器是相对的）

可用参数：
start | end | center | stretch | space-between | space-evenly | space-around



align-items		栅格内所有元素的垂直排列方式

justify-items		栅格内所有元素的横向排列方式

justify-content		容器有额外空间时，所有栅格在容器中的水平对齐方式

align-content		容器有额外空间时，所有栅格在容器中垂直对齐方式

以下两种控制单个元素的对齐：

align-self			元素在栅格中垂直对齐方式

justify-self		元素在栅格中水平对齐方式






对代码尤其是关键代码的注释非常重要













#### 变形动画

（可以以X-Y-Z 3维坐标轴为平台,Z轴是与屏幕垂直）
1：让某元素左右或者上下移动，就可以设置该元素：
transform:translateX(100px);/*左右移动，正负符号控制方位*/
transform:translateY(100px);/*上下移动，正负符号控制方位*/



2：让元素斜方向移动：
transform:translateX(100px) translateY(100px);
或者简写：
transform:translate(100px,100px);



3：可以在该元素的父元素那设置该元素移动变换的时间,当然也可以在本元素上直接设置：
transition:2s;



4:transform方法让元素居中：

```html
<style>
    body {
        height: 100vh;
    }

    main {
        width: 400px;
        height: 400px;
        border: solid 5px silver;
        position: relative;
    }

    main div {
        width: 100px;
        height: 100px;
        background: blueviolet;
        position: absolute;
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
    }
</style>

<main>
    <div></div>
</main>

```



使用该方法的一个特点就是无论width和height怎么变化，元素都是居中对齐的,

==注意父级一定要加position:relative==



5：沿Z轴（穿透屏幕）方向移动的方法

```css
1：设置两元素在屏幕沿Z轴的位置
div:nth-child(1) {
            background: #2ecc71;
            transform: perspective(900px) rotateY(65deg);
            /*让元素朝Z轴倾斜*/
        }
         /* rotateY控制元素沿Y轴放置（垂直），rotateX控制元素沿X轴放置（水平），里面的值对应的是倾斜的值 */
    /* 要让元素在Z轴移动，就必须要先设置透视（perspective）,和rotateX/Y,两者必须搭配使用来让元素垂直屏幕放置 */
    /* 接着设置要移动的元素translateZ(200px) ,里面的值控制移动的长度*/
    div:nth-child(2) {
        background: #e67e22;
        transform: perspective(900px) rotateY(65deg);
        /*让元素朝Z轴倾斜*/
    }
2：设置要移动的元素的移动规则
        main:hover div:nth-child(2) {
            transform: perspective(900px) rotateY(65deg) translateZ(200px);
        }
   可以很容易的想象出这就是相当于整个三维坐标轴首先沿着屏幕往Z轴倾斜了一定角度
坐标轴倾斜之后元素沿XY轴移动：
 main:hover div:nth-child(2) {
            transform: perspective(900px) rotateY(65deg) translate(200px，200px);/*也可以使用百分数*/
        }
```



3：translate3d方法使用(这是同时对三个轴进行统一控制，和translateX/Y/Z是平行关系，对于某一个轴不设置的话值就为0)
 main:hover div:nth-child(2) {
            transform: perspective(900px) rotateY(65deg) translate3d(200px,200px,200px);
        }



6:缩放
缩放我们使用scale,例如沿X轴缩放（即拉伸）：
 main:hover div:nth-child(2) {
            transform: scaleX（2);/*数值为1表示没有变化，数值大于1为拉伸，小于1为缩小*/
        }

6.2：同时控制X,Y轴的缩放：
scale(2 , .5);

6.3:控制Z轴缩放：
scaleZ( .5)/*注意在使用Z轴时一定要在父级元素和自身设置透视（perspective）才可以观察出效果*/

6.3：同时控制三个轴的拉伸：
scale3d( 2, 2, 6);


6.4使用该特性可以用来隐藏显示指定元素
transform:scale(0);/*隐藏*/
transform:scale(1);/*显示*/

使用这一特性的好处就是可以设置transition,用来控制要显示的时间；
transition:2s;

当然为了元素显示的更加好看，我们还要修改元素缩放的基准点：
transform-origin:left top;/*从左上角开始缩放显示*/




7：旋转
rotateX(45deg)/*按照X轴旋转，正号就是以X轴为轴心，元素往你的前面旋转，负数就是往你的后面旋转*/
当然，为了更好的可视化显示，需要搭配透视效果（perspective(900px)）来实现效果，还要使用transition:2s来实现过渡（要让哪一个元素过渡就给那一个元素添加transition,尽量不要添加到它的父元素，也不要添加到该元素hover之后，否则有可能会导致过渡效果失效）


rotate3d(1, 0, 0, 195deg);/*分别对应x轴, y轴, z轴以及旋转变换的角度*/
rotate(angle)		定义 2D 旋转，在参数中规定角度。
rotate3d(x,y,z,angle)	定义 3D 旋转。
rotateX(angle)		定义沿着 X 轴的 3D 旋转。
rotateY(angle)		定义沿着 Y 轴的 3D 旋转。
rotateZ(angle)		定义沿着 Z 轴的 3D 旋转。


8：倾斜
main:hover div:nth-child(2){
   transform:skew(-45deg,45deg);/*同时控制元素在X轴，Y轴的倾斜*/
}
对于只对X轴进行倾斜，可以直接设置skew(45deg);
如果要单独对Y轴进行倾斜，应当设置为skew(0,45deg);

skew(x-angle,y-angle)	定义沿着 X 和 Y 轴的 2D 倾斜转换。
skewX(angle)		定义沿着 X 轴的 2D 倾斜转换。
skewY(angle)		定义沿着 Y 轴的 2D 倾斜转换。



9:参考点设置（元素旋转的基准点）
只需要设置指定元素为：
transform-origin:right bottom;/*方向可以任意指定，也可以使用数值来操作控制*/

三维参考点的设置：
transform-origin:left bottom 300px;(Z轴不可以使用百分比)



10：透视
perspective
要注意的两点是:
1:==该属性的值越大，就可以想象成对该物体（山）离的越远，那么选定元素就可以看的全面，数值越小，看的越小，选定的元素也就越大==
2：需要配合旋转（rotate）来使用；

10.2（建议使用）
main:{
   display:flex;
transform:perspective(600px) rotateY(45deg);/*对于自身及其子元素都会同时设置*/
   }

10.3（不建议使用）
main:{

    perspective:600px;/*只作用于子元素*/

}



11：三维空间
==在使用透视之后，如果想要观察立体观察两个元素，可以使用transform-style:preserve-3d;==
==这样就可以达到在该元素及其子元素都设置了透视倾斜了之后可以看到两个元素==

只要有Z轴参与，就可以使用这一个属性！













#### 过渡延迟

这一CSS属性我们使用transition来实现，适用于同一个元素它的特征（颜色，大小等）有一个变化，我们就可以使用该属性来让特征之间的变换慢一点，可以看到一个过渡过程

1：设置变化的特征
一般我们都是直接使用transition来实现过渡延迟==transition-property:all==，但是如果我们只需要控制一个特征，比如颜色实现延迟过渡；使用==transition-property:background;==
该属性的默认值为all,指全部变化，也可以禁用过渡延迟,即transition-property:none;
接着再使用==transition-duration:2s==即可；



2：有些时候我们可以不用直接在html代码当中直接添加类（class）,而是在css中设置某一个标签有一个类,也即是假定有该类（exp:div.test），接着使用JS监听该属性并添加该类做相关操作



3：在使用绝对定位（position:absolute;的时候，该元素有可能会无法查看，这时在它的父元素设置相对定位即可（position:relative;））



4:分别设置某一个属性的每一个特征的过渡效果：
transition-property:background,width,height;
transition-duration:200ms ,1s, 3s; 



5:设置元素在过渡变化的过程中的速度（先快后慢，先慢后快等）
==transition-timing-function:liner;==
linear			规定以相同速度开始至结束的过渡效果（等于 cubic-bezier(0,0,1,1)）。
ease			开始慢，然后快，慢下来，结束时非常慢（cubic-bezier(0.25,0.1,0.25,1)）
ease-in			开始慢，结束快（等于 cubic-bezier(0.42,0,1,1)）
ease-out			开始快，结束慢（等于 cubic-bezier(0,0,0.58,1)）
ease-in-out		中间快，两边慢（等于 cubic-bezier(0.42,0,0.58,1)）
cubic-bezier(n,n,n,n)	在 cubic-bezier 函数中定义自己的值









6:步进速度
transition-duration:2s;
transitin-timing-function:steps(60,start);/*分六十步走完*/
steps(n,start)			设置n个时间点，第一时间点变化状态
steps(n,end)			设置n个时间点，第一时间点初始状态
step-start				等于steps(1,start)，可以理解为从下一步开始
step-end				等于steps(1,end)，可以理解为从当前



7：控制定点(定时)显示
==transition-delay:1s==;(设置元素为hover之后，鼠标移动到元素区域内1s后才会触发)
可以同时设置多个值
exp:
transition-property:border-radius,background,width,height;
transition-delay:0ms, 2s, 4s, 4s;



8：一条规则设置所有属性
transition:border-radius liner 2s 0s,
                background 2s 2s,
                width   liner 2s 4s,
	height liner  2s 4s;(选定属性  线性 动作持续时间  等待多少秒之后开始动作)













#### 帧动画

1：基础使用
1.1要在哪一个元素上使用帧动画，就在该元素上写：
animation-name:'name';/*这里的名字可以是一个或者多个*/
animation-duration:'second';
1.2接着打上关键帧：
@keyframes 'name'{/*0%以及100%可以不用写，默认属性为关键帧之前的属性*/
   25%{}
   50%{}
   75%{}
 }
1.3对一些关键帧可以同时统一设置样式：
25%，50%{}
1.4简洁模式
@keyframes hd {
        from {
            opacity: 0;
            transform: scale(.1);
        }

        to {
            opacity: 1;
        }
    }


from 表示起始点
to表示终点





2：多个属性设置动画
animation-name:'name1'，'name2';
animation-duration:'second1','second2';
一个关键帧对应一个设置好的属性名称，帧动画名称数量大于帧动画时间设置量，那么时间将会循环使用；


3：使用帧动画的条件，元素的变化有一个中间值；


4：帧动画循环显示：
animation-iteration-count:100;/*该属性默认为1，可以同时设置多个值*/
当设置值为infinite时，就表示该属性动画无限执行！

5：控制动画来回时间的快慢：
animation-direction:normal/*来的时候按照时间慢慢来，回的时候快*/
animation-direction:reserve/*先回的时候慢，接着来的时候快*/
animation-diretion:alternate/*来回都是按照指定时间慢慢进行*/
animation-diretion:alternate-reverse/*100%-0%-100%*/



6:控制帧动画等待多少时间之后再开始动画：
animation-delay:2s;


7:控制速率变化效果

animation-timing-function:ease;
linear			规定以相同速度开始至结束的过渡效果（等于 cubic-bezier(0,0,1,1)）。
ease			开始慢，然后快，慢下来，结束时非常慢（cubic-bezier(0.25,0.1,0.25,1)）
ease-in			开始慢，结束快（等于 cubic-bezier(0.42,0,1,1)）
ease-out			开始快，结束慢（等于 cubic-bezier(0,0,0.58,1)）
ease-in-out		中间快，两边慢（等于 cubic-bezier(0.42,0,0.58,1)）
cubic-bezier(n,n,n,n)	在 cubic-bezier 函数中定义自己的值




8：步进速度（让元素跳机械舞一样动）：
animation-timing-function:steps(4,start);
animation-timing-function:steps(4,end);

steps(n,start)		设置n个时间点，第一时间点变化状态
steps(n,end)		设置n个时间点，第一时间点初始状态
step-start			等于steps(1,start)，可以理解为从下一步开始
step-end			等于steps(1,end)，可以理解为从当前步开始



小贴士：在对一个元素使用绝对定位时(position:absolute)，如果想让其根据父元素或者最近元素来进行定位，需要在祖先元素上设置属性继承，即（position:relative）




9:播放状态
animation-play-state:
paused:暂停
runing:运行

10：填充模式
animation-fill-mode
用于定义动画播放结束后处理模式，是回到原来状态还是停止在动画结束状态
none			需要等延迟结束，起始帧属性才应用
backwards		动画效果在起始帧，不等延迟结束
forwards			结束后停留动画的最后一帧
both			包含backwards与forwards规则，即动画效果在起始帧，不等延迟结束，并且在结束后停止在最后一帧













#### 媒体查询

（响应式布局基础）
功能是在不同的条件下使用不同的样式，使页面在不同的终端下达到不同的渲染效果
1：在屏幕显示与打印设备上不同的CSS效果

<style media="screen">
h1{
 font-size:3em;
color:blue;  
}
</style>
<style>
h1{
  font-size:8em;
color:red;
  }
h2,hr{
display:none;    
}
</style>


2:也可以使用link的方法来引入对应媒体设备的样式
<link rel="stylesheet" href="common.css">/*没有指定媒体所以全局应用*/
<link rel="stylesheet" href="screen.css" media="screen">/*应用在屏幕设备*/
<link rel="stylesheet" href="print.css" media="print">/*应用在打印设备*/
可以在CSS文件中使用@media再定义媒体样式



3：使用@import可以引入指定设备的样式规则，CSS文件中引入一个样式文件，在这个文件中再引入其他媒体的样式文件（推荐使用）
HTML引入
<link rel="stylesheet" href="style.css">

CSS文件
style.css
@import url(screen.css) screen;
@import url(print.css) print;

@import url(small-x.css) only screen and (max-width:768px)
@import url(small.css) only screen and (min-width:768px)
@import url(medium.css) only screen and (min-width:960px)
@import url(big.css) only screen and (min-width:1200px)





4：可以使用@media做到更细的控制，即在一个样式表中为多个媒体设备定义样式
<style>
@media screen{
  h1{
    font-size:3em;
    color:blue;
      }
   }
@media print{
   h1{
  font-size:8em;
  color:red;
       }
h2,hr{
    display:none;
         }

     }

</style>




5:查询条件
5.1逻辑与（多个条件使用and连接）
exp:需要同时满足横屏显示以及宽度不能超过600px;
 <style>
        @media screen and (orientation: landscape) and (max-width: 600px) {
            body {
                background: #8e44ad;
            }

            h1 {
                font-size: 3em;
                color: white;
            }
        }
    </style>



5.2逻辑或（多个条件查询使用逗号连接）
exp:(如果设备是横屏显示或者宽度不超过600px时就使用样式规则)
 <style>
        @media screen and (orientation: landscape),
        screen and (max-width: 600px) {
            body {
                background: #8e44ad;
            }

            h1 {
                font-size: 3em;
                color: white;
            }
        }
    </style>



5.3不应用（not 表示不应用样式，即所有条件都满足时不应用样式。）
必须将not写在查询的最前面
exp:
<style>
        @media not screen and (orientation: landscape) and (max-width:600px) {
            body {
                background: #8e44ad;
            }

            h1 {
                font-size: 3em;
                color: white;
            }
        }
    </style>



5.4排除不支持媒体查询的浏览器（only）
1:对不支持媒体查询的设备，正常调用样式，此时就当only不存在；
2：对不支持媒体查询的设备不使用样式
3：only和not一样只能出现在媒体查询的开始
exp:
@media only screen and (orientation: landscape) and (max-width: 600px) {
	...
}





6:查询特征
常用特征
orientation: landscape | portrait	landscape横屏，portrait竖屏
width				设备宽度
height				设备高度
min-width			最小宽度
max-width			最大宽度
min-height			最小高度
max-height			最大高度

exp:
1：在支持媒体查询的设备并且设备宽度为568px时使用样式
@media only screen and (width:568px) {
    ...     
}

2：在设备不小于569px，并且支持媒体查询的设备时使用样式
@media only screen and (min-width:569px) {
	...
}


3：在横屏设备并且宽度大于569px时使用样式
@media only screen and (orientation: landscape) and (min-width:569px) {
	...
}




7:rem
CSS文件中：
:root{
 font-size:15px  
 }

.logo{
  font-size:1.5rem;
   }

这样写的好处有利于开发效率，只需要改动这一个地方就可以改变整体大小
这里的:root也可以写成html，意思就是浏览器默认的尺寸，通过对这一个属性的设置，就可以改变浏览器的默认值，这样在后续的开发当中就可以以这一个为基准；

8：vh和vw单位的意思是把屏幕等分成一百份，然后我们可以按照比例来使用，它可以使用在任何一个元素里面，它是相对于视口的高度和宽度；
而CSS百分比是相对于包含它的最近父元素的高度和宽度


9：浏览器在初始的时候给我们默认了一些边距，我们需要通过浏览器的检查功能来分析页面




10：
不同终端通用尺寸：
超小屏幕（手机）  <768px
小屏设备（平板）  768px<~<992px
中等屏幕（桌面显示器）  992px<~<1200px
宽屏设备（大桌面显示器）  ~<1200px





























































## JS



https://www.cnblogs.com/Renyi-Fan/p/11590231.html

https://blog.csdn.net/qq_43043859/category_9259650.html

#### 创建变量

var price=5,quantity=14;可以一次性定义变量和值以及方法


JS在命名变量的时候要规范，要尽量使用对应的英文单词词组，对于词组可以使用驼峰命名法（firstName）







#### 数值

> **算术运算符**

1：+-*/%,其中只有+可以用于两个字符串的连接
2：递增运算符：++    递减运算符：--
3：三目运算符：（条件）？（符合条件输出）：（不符合条件输出）



* isNaN()检查值是否为数字

* toFixed()将特定数字四舍五入至指定小数位数，返回的是一个字符串（exp:toFixed(3)）













#### 字符串

> **查找字符串的位置**

**indexof()**返回==某个字符串在字符串中首次出现的位置（下标）==，==如果搜索到尾部还没有找到，返回-1==
Indexof(a,b)中a是字符串，b是开始查找的位置，可以是负数，-1表示倒数第一个元素；

```js
var short = "ab";
var long = "aabccccaab";
var mix = "cdef";
long.indexOf(short);//返回1
long.indexOf(short,4);//返回8
long.indexOf(mix);//返回-1
```



**lastindexof()**和indexof()功能相似，区别是搜索方向是从后往前搜索；





> **求指定位置的字符**



* **charAt()**   ==作用是返回调用者指定位置的字符，位置从0计数==

  ```js
  var str = "abcdefg";
  console.log(str.charAt(0));//输出a
  console.log(str.charAt(str.length-1));//输出g
  ```

  

* **includes()**==判断字符是否存在，返回布尔类型值==

  `  console.log(str.includes("a",0));//true`



* **starWith()**==判断是否以指定字符串开头，返回布尔值==

  `console.log(str.startWith("a"));//true`



==判断是否以指定字符串结尾，返回布尔值,不区分大小写==

`console.log(str.toUpcaser().rendWith("a"));//true`





> **字符串的截取**

* **slice()**

slice(a,b)的作用是截取a位置（含）到b位置（不含）之间的字符串，
==被截取的字符串不变==，返回截取后获得的子字符串。



* **substring()**

substring(a,b)与slice(a,b)功能相同，参数的意义也相同：a和b都是表示位置的数字。
只是参数的处理有些不同：
==a或b为负数时，自动转换为0；==
==a大于b时，编译器会自动对调两者。==



* **substr()**

substr(a,b)指定==开始位置==和要==截取的长度==





> **大小写转换**

* toLowerCase()

==把字符串中的所有大写英文字母转为小写，返回转换后的字符串，但是操作该函数的字符串不变==

```js
var upperStr = "aBCd";
var lowerStr = upperStr.toLowerCase();
console.log(upperStr);//输出aBCd
console.log(lowerStr);//输出abcd
```





* toUpperCase()
  ==把字符串中的所有小写英文字母转为大写，返回转换后的字符串，但是操作该函数的字符串不变==

  ```js
  var str = "asdf";
  var strin = str.toUpperCase();
  console.log(str);//输出asdf
  console.log(strin);//输出ASDF
  ```

  



> **字符串的分割**

* split()与join()的作用相反，split()以指定的字符分割字符串，从而得到一个子字符串数组

* trim()   删除字符串开始和结束的空格

* length 获取当前字符串的字节长度



> **字符串的替换**

replace()用于字符串的替换,exp:replace('me','w');第一个值是要被替换的字符





> **字符串转化为数字的几种方法**

```js
const string = "99";
const string1="99.23sriugheriub"
```

* **与一相乘**

`console.log(string*1+67);`

* **使用number**

`console.log(Number(string)+67);`

* **使用parseInt**

`console.log(parseInt(string1));//99.23`



> **其他类型数据转化为字符串**

* **使用+号**

```js
const number=66;
const str = number + "";
console.log(str);
```



* **使用String()**

`console.log(String(number));`



> **字符串转化为数组(split())**

```js
const cms="dfhrth"
console.log(cms.split(""));
```



> **数组转化为字符串**

==join()==

```js
const array=["dfgrrt","dfgrt"];
console.log(array.join("|"));
```



==toString()==

```js
const array=["dfgrrt","dfgrt"];
console.log(array.toString());
```



> **字符串转整数**

parseInt("12")   parseInt("C",16)  Number("12")

> **字符串转小数**

parseFloat("12.2")    Number("12.2")

> **数字转字符串**

console.log(myNum.tostring(16));    console.log(String(myNum));

















#### 数组

> **数组的创建**

* `var numberArray = [1,2,3,'python',true,4]`

* `var myArray = new Array();（避免使用）`

  当里面只有一个值的时候，该值表示创建的数组的长度

* `let arr = Array.of(6);`

  定义一个长度为六的数组，使用此方法不用担心由于没有定义的空间出现问题，否者为undefind;



> **读取**

`var read=numberArray[0]`



> **写入**

对某一个元素重新赋值



> **数组长度**

numberArray.length(数组的长度也可以写入，当写入的值小于数组的实际长度时，数组会被删除一部分，大于实际长度时，数组的尾部添加一些空的区域)



==注意，这里的numberArray表示数组的名字，我们可以随意定义==





> **数组元素的增加**

* 直接通过下标添加

```js
var numberArray=[1,2,3,4];
numberArray[numberArray.length]=7;#添加
```



* 使用push()函数

`var newlength=numberArray.push(7)`



* 在头部添加元素

`var newLength=numberArray.unshift("he","llo");`



* 把一个数组添加到另外一个数组（即合并两个数组）

  ```js
  let arr = ["dfrhtr","dfbh"];
  let hd = ["fg","dsg"];
  arr = [...arr,...hd];
  console.log(arr);
  ```

  

* 指定位置添加

  ```js
  console.log(Array(5).fill("xiaohui"));
  console.log([1,2,3,4].fill("xiaohui",1,3));//[1,"xiaohui",2,"xiaohui",4]
  ```

  





> **数组元素的删除**

* 修改数组长度
  `numberArray.length=3;`

* 使用delete运算符
  `delete numberArray[0];`

* 使用pop(),一次删除一个
  `var deletenumber=numberArray.pop();`

* 在头部删除元素
  `numberArray.shift();#一次删除首部的一个`







> **数组的遍历**

* 使用for循环（和c语言一样）

  ``` js
  let lessons =[
  {title:"好好学习",name:"xiaohui"},
  {title:"天天向上",name:"xiaomei"},
  {title:"天道酬勤",name:"xiaoli"}
  ];
  for(let i=0;i<lessons.length;i++){
  lessons[i].title = `刘辉${lessons[i].title}`;
  }
  ```

  

  ```js
  for(const value of lessons){
  value.title = `刘辉${value.title}`;
  }
  ```

  

  ```js
  for(const key in lessons){
  lessons[key].title = `刘辉${lessons[key].title}`;
  }
  ```

  

  

* forEach()方法

  该方法有三个参数，第一个是当前的数组元素，第二个是当前索引，第三个是数组对象索引

```js
var numArr = [10,11,12,13,14];
numArr.forEach(function(mem,i,arr) {
    mem *= 10;
    arr[i] = mem;
});
console.log(numArr);//输出[100,110,120,130,140]
```



> **多维数组实现**

* 创建已知的二维数组
  `var multiArr = [[1,2,3,4],[5,6,7],[8,9]];`

  

* 创建仅知道长度的二维数组

  ```js
  //创建一个4行6列的二维数组
  var muArr = new Array(4);
  for(var i = 0;i <4;i++) {
      muArr[i] = new Array(6);
  }
  ```

  





> **其他类型转化为数组**

`let str = "dfgjer"`

* 方法一：`str.split(",");`

* 方法二：` Array.from(str);`

* 方法三：` const [...arr]="sdgrdh";`



> **数组解构**

```js
let arr = ["xiaohui",1999];
let[name,year]=arr;
console.log(name,year);
```







> **splice函数（可同时实现增加，删除，替换）**

```js
let arr = [1,2,3,4,5]
arr.splice(1,1,'sdgfb');//替换下标为1的值（第一个参数表示下标，第二个参数为1表示删除，为0表示添加）
arr.splice(1,0,'sdgfb');//增加元素到指定下标
```





> **slice方法**

```js
var arr = ["a","b","c","d","e"];
console.log(arr.slice(0,3));//["a","b","c"]
console.log(arr.slice(0,-2));//["a","b","c"]
console.log(arr.slice(4));//["e"]
console.log(arr.slice(-4));//["b","c","d","e"]
```







> **清空数组**

`let hd = [1,2,3,4,5];`

* 方法一：hd=[];//操作的是一个新的空数组

* 方法二：hd.length=0;//操作的是原数组

* 方法三：hd.splice(0,hd.length);



> **复制数组元素到指定位置**（copyWithin()）

```js
let hd = [1,2,3,4,5,6];
console.log(hd.copyWithin(3,1,3));//把1和3从数组下标为3的位置开始复制结果为：[1,2,3,2,3,6];
```







> **几种数组元素查找方法**



* includes()函数查找

```js
let arr = [1,2,3,4,5,6];
console.log(arr.includes(2))//true
```





* find()(返回值)     findIndex()（返回值的下标即所在位置）

```js
let lessons = [{name:"js"},{name:"css"},{name:"mysql"}];
let status = lessons.find(function(item){
return item.name="css";
});
cosole.log(status);
```



> **map**()方法

map（）方法创建一个新的数组，其结果是该数组中每一个元素都调用一个提供的函数后返回的结果；

```js
let array1 = [1,4,9,6];
const map1 = array1.map(x=>x*2);
console.log(map1);//[2,8,18,12]


```



> **数组的合并**(concat)

数组`a.concat`(数组b)



> **数组倒置**(reverse)

数组`var b=a.reverse();`数组a和b都会被倒置



> **元素合并**(join)

```js
var sArray = ["June","July","August"];
console.log(sArray.join());//输出June,July,August
console.log(sArray.join("+"));//输出June+July+August
```





> **元素排序**

* ```js
  var arr = [1,2,10,5,12];
  arr.sort();
  ```

* ```js
  console.log(arr);//输出[1,10,12,2,5]
  console.table(arr);
  ```

* ```js
  arr.sort(function(a,b){
       return a-b;
  });
  console.log(arr);//输出[1,2,5,10,12]
  arr.sort(function(a,b){
       return b-a;
  });
  console.log(arr);//输出[12,10,5,2,1]
  ```

* 对数组对象进行排序

```js
let cart = [
{name:"iphone",price:12000},
{name:"imac",price:18000},
{name:"ipad",price:3200}
];
cart = cart.sort(function(a,b){
return b.price-a.price;
}
);
cosole.table(cart);
```








> **数组的内排序**



* 冒泡排序(一趟冒泡排序结束后最大的元素已经移到了索引最大处)

```js
var arr = [9，5，8，0，2，6];
var aLength = arr.length;
var temp;
var flag = 0;//元素交换的标志位
for(var i = 1;i < aLength;i++) {//共进行n-1次冒泡
    flag = 0;
    for(var j = 0;j < aLength-i;j++) {//一次冒泡
        if(arr[j]>arr[j+1]) {//交换元素
            temp = arr[j];
            arr[j] = arr[j+1];
            arr[j+1] = temp;
            flag = 1;
        }
    }
    if(flag == 0) break;//本次冒泡没有元素交换
}
```



* 选择排序

遍历数组，记录下最大元素的索引值，将最大的元素与数组最后一个元素交换。这样最大的元素到了索引值最大的地方

```js
var arr = [6,12,3,34,1,56,77,0,2,43];
var aLength = arr.length;
var temp;
var max = arr[0];
var maxIndex = 0;
for(var i = 0;i < aLength-1;i++) {//共进行n-1次选择
    for(var j = 1;j < aLength-i;j++) {//一次选择
        if(arr[j] > max) {
            max = arr[j];#不断更新最大值的位置
            maxIndex = j;#不断更新最大值的索引
        }
    }
    //将本次选出的最大元素移动到最终的位置上
    temp = arr[aLength-i-1];
    arr[aLength-i-1] = arr[maxIndex];
    arr[maxIndex] = temp;
    var max = arr[0];
    var maxIndex = 0;
}
```









#### Boolean类型隐式转化原理

true----1
false---0

if([])  console.log("xsdgdf");
if({})  console.log("dsvg");

其他类型转化为布尔类型
1:let number = 0;    number = !!number;
2:==console.log(Boolean(number))==







#### 函数

作用：==封装需要重复使用的代码==

> **函数定义**

* **用函数语句定义函数**

函数的定义是指用一段代码实现函数的功能，通常的定义方式以关键字function开头。

```js
function sumArray(arr) {
    var sum = 0;
    for(var i = 0,aLength = arr.length;i < aLength;i++) {
        sum += arr[i];
    }
    return sum;
}
```



==要注意的是函数可以返回一个数组，具体使用是定义一个变量，该变量用于获取具有多个值的数组，最后单独返回该变量即可==



* 用表达式定义函数（匿名函数）

```js
var funct = function getMax(a,b) {
    return a>b?a:b;
};//注意这里的分号不能少，因为我们定义的是一个变量！
console.log(funct(1,2));//输出2
```

或者

```js
var funct = function(a,b) {
    return a>b?a:b;
};


```



* **立即调用函数表达式**（IIFE，用作一组代码的封装器，可以有效地保护变量）

```js
var area = (function(){
var width = 3;
var height = 2;
return width * height;
}()//注意不要遗漏这一个括号
);
```



==要注意的是匿名函数以及函数表达式（及其立即调用）用于任务中只需要运行一次的代码，而非脚本上需要多次反复调用的情况==
1：当函数被调用时作为实参（为此函数计算出一个值）

2：用于为对象的属性赋值；

3：用于事件处理程序和监听器

4：用于防止在两段脚本上因使用相同的变量而产生冲突



==应当尽量避免大量的定义全局变量，因为全局变量使用更多的内存==，浏览器需要在整个页面载入期间保存它们，而==局部变量只需要在函数执行期间被保存（多定义函数，对象）==





> **对象里定义的函数的调用方法**

```js
var ob = {
    id:1,
    getMax:function(a,b) {
        return a>b?a:b;
    }
};
```



简写：

```js
var ob = {
    id:1,
    getMax(a,b) {
        return a>b?a:b;
    }
};
```



`var result = ob.getMax(2,1);`//result值为2
`var result1 = ob["getMax"](2,1);`//result1的值也是2
这里要定位到函数，需要使用==对象名.函数名==或者==对象名["函数名"]==,其它相同





> **未定义的实参处理**

给可能被传入undefined的值的形参设定一个默认值

```js
function getSum(a,b,c) {
    if(c === undefined) 
        c = 0;
    console.log(a+b+c);
}
myFunction(1,2);
```





> **实参对象**

实参对象一个最重要的应用是可变长参数列表，想象一下==求一组数的和，
如果这组数不在一个数组里面，使用函数来求则无法定义函数体，因为不知道形参的个数==。
这个时候就可以用arguments来解决问题。

```js
function getSum() {
    var aLength = arguments.length;
    var sum = 0;
    for(var i = 0;i < aLength;i++) {
        sum += arguments[i];
    }
    return sum;
}
console.log(getSum(1,2,3,4,5))//输出15
```



或者使用reduce方法

```js
function getsum(...args){
return args.reduce((a,b)=>a+b);
}
console.log(getSum(1,2,3,4,5))//输出15
```





> **对象作为参数**

```js
function myFunction(obj) {
    console.log(obj.name);
    obj.number++;
    return obj.number;
}
myObj = {name:"myObj",number:34};
myFunction(myObj);//输出myObj
console.log(myObj.number);//输出35
```



> **函数对象**

```js
function getMax(a,b) {
    return a>b?a:b;
}
//求最小值
function getMin(a,b) {
    return a<b?a:b;
}
//下面这个函数以函数作为参数，并最终返回一个值
function getM(func,num1,num2) {
    return func(num1,num2);
}
getM(getMax,1,2);//返回2
getM(getMin,1,2);//返回1
```





> **箭头函数**

```js
let hd = function(){
return 1+2;
};
```



`let hd = () => 1+2;`//箭头后面对应的是值

特点：
1：函数必须赋值给一个新的变量；
2：在原型函数的基础上删除了function和{}以及return；



> **在外部调用函数里面的另外一个函数方法**

首先要在外部声明一个全局变量，接着在函数内部把又定义的一个函数赋值给该变量；
接着就可以通过调用该变量来调用该函数内部的函数了；



> **filter**()筛选函数的使用方法

```js
let arr=[1,23,3,6,7,8,9];
let hd=arr.filter(function(v){return v>=2 && v<=9;});/*3,6,7,8,9*/
```













#### 对象

> **对象创建**



* 对象字面量

  ```js
  var song={
      name:"Liekkas",
      time:180,
      "song lanuage":English,
      singer:{
         singerName:"Sofia Jannok",
             singerAge:30
  }
  };
  ```

  

* 通过关键字new创建对象

  ```js
  var Store=new Object();
  Store.name="lofo Market";
  Store.location="NO.13 Five Avenue";
  Store.salesVolume=100000;
  ```

  

* 通过工厂方法创建对象(创建该对象只需要调用该函数即可，适用于一次创建多个对象)

```js
#对象创建函数
function creatStoreObject(name,location,salesVolume){
var store=new Object();
store.name=name;
store.location=location;
store.salesVolume=salesVolume;
store.display=function(){
    console.log(this.name);
};
return store;
}
#利用该函数创建一个对象
var store1=createStoreObject("pandas express","No.1,People Street",200000);
var store1 = new store("pandas express","No.1,People Street",200000);
```







* 使用构造函数创建对象（构造函数名必须以大写字母开头，函数体没有返回语句）

```js
#构造函数
function Store(name,location,salesVolume){
    this.name=name;
    this.location=location;
    this.salesVolume=salesVolume;
}
#创建对象实例
var myStore=new Store("KeyExp","No.1,L.Street",540000);
```



* 使用原型（prototype）创建对象

```js
function Store(){};
Store.prototype.name="SF Express";
Store.prototype.name="Hong Kong";
Store.prototype.salesVolume=12000000;
#创建对象
var myStore=new Store();

#创建一个新的对象
var hisStore=new Store();
hisStore.name="STO Express";
```





> **对象 属性的增删查改**



* **属性的获取**

方法一：使用‘.’符号，符号左侧是对象的名字，右边是属性的名字

```js
var student = {name:"Alice",gender:"gile"};
cosole.log(student.name);#输出
```



方法二：使用[""]符号，符号左边是对象的名字，双引号中间是属性的名字（该属性可以是任何形式，比如是一个表达式）

```js
var student = {name:"Alice",gender:"gile"};
console.log(student["name"]);#输出
```



* **属性的修改和新增**

直接对属性进行赋值即可

```js
var student={name:"kom",age:21};
student.age=20;#修改属性，覆盖原来的值
student.gender="female";#新增属性
```



* **属性的删除**

```js
var Store=new Object();
Store.name="Bob";
Store.location="No.12 Five Avenue";
console.log(delete Store.name);#删除成功，输出True
console.log(Store.name);#对于已经删除的属性，输出undefined
delete Store.prototype;#删除失败，非自有属性
```





> **对象属性的检测和枚举**



* **属性的检测**

方法一：使用运算符in，in的左侧是属性或者方法名，右侧是检测对象，对象有该属性或者方法返回true;


```js
var school={
    name:"SJTU",
    location:"Shanghai",
    studentNum:4000,
    display:function(){
        console.log(this.name);
    }
};
#检测属性
console.log("name" in school);
console.log("sales" in school);
#检测方法
console.log("display" in school);
```




方法二：使用hasOwnProperty(),括号内的参数是属性或者方法的名字
`console.log(school.hasOwnProperty("studentNum"));//true`





* **属性的枚举**

方法一：

```js
for(var att in school){
    console.log(att);
}
```



方法二：
`console.log(Object.getOwnPropertyNames(school));`



方法三：
`console.log(Object.keys(school));//返回的是对象中所有的键`
`console.log(Object.values(school));//返回的是对象中所有的值`





> **对象的解构**

```js
let user = {name:"小灰",age:18};

const {name,age}=user;(直接调用键即可！)

let { age } = user;//18

console.log(name,age)//"小灰",18
```





> **变量转化为对象**

```js
let name = "小灰"，
url = "xiaohui";

let opt = {name,url};
console.log(opt);//{name:"小灰"，url:"xiaohui"}
```





> **对象的复制**

方法一：

```js
let hd ={name:"刘辉",title:"好好学习"}；
let obj = {...hd}//这种复制是开辟了一个新的内存空间地址
```



方法二：
(object.assign())

```js
let hd ={name:"刘辉",title:"好好学习"}；
let obj = object.assign({},hd);
console.log(obj);
```



方法三：（可以在复制的同时添加一些东西）

```js
let obj = {};
for(const key in hd){
obj[key] = hd[key] + "刘辉"；
}
```





> **不允许向对象中添加属性**API的方法

方法一：`object.isExtensible(user);`//user是一个对象


方法二：`object.seal(user);`

方法三：`object.freeze(user);`



> **补充**

==对象中可以包含数组，数组中也可以包含对象；==

==在对象中，变量即对象的属性函数即对象的方法，此外，数组和对象也被视为真值（即True）==









#### JSON对象

> **JSON对象与Javascript对象的区别**

* ==JSON对象的属性名（key）必须被包含在双引号之中==，而JavaScript对象除了有空格的属性名、中间有连字符-的属性名必须在双引号之中外，其它随意；

* ==不能在JSON对象中定义方法(即函数)==，而在JavaScript对象中可以；

* JSON对象可以被很多语言操作，而JavaScript对象只有JS自己可以识别。





> **JavaScript中JSON对象的增删查改**

* **JSON对象定义**

`var jsonObject = {"name":"js","number":2};`



* **操作属性**

> 使用.或者[]

`console.log(jsonObject.name);//读属性，输出js`
`console.log(jsonObject["name"]);//读属性，输出js`
`jsonObject.name = "javascript";//写属性，给name属性赋值javascript`





* **删除属性**

> 使用delete

```js
var jsonObject = {"name":"js","number":2};
delete jsonObject.name;//删除name属性
```



* **遍历属性**

> 使用for-in循环

```js
var jsonObject = {"name":"js","number":2};
for(att in jsonObject) {
  console.log(jsonObject[att]);//依次输出js、2
}
```





> **JSON数组**



JSON键值对中的值(value)可以是一个数组，比如：

```js
{
"country":"China",
"population":"1.3billion",
"bigCity":["Peking","Shanghai","ShenZhen","HongKong"]
}
```



==属性bigCity的值有多个，放在一个数组里面。==

上面例子里面，数组的每一个元素都是字符串。其实，==数组的每一个元素还可以是另外一个json对象==

比如：

```js
{
"class":"高三一班",
"studentNumber":70,
"score":[
    {"name":"LiMing","score":128},
    {"name":"ZhangHua","score":134},
    {"name":"ShenLu","score":112}
]
}
```



> **读写元素**

```js
var myJson = {
"country":"China",
"population":"1.3billion",
"bigCity":["Peking","Shanghai","ShenZhen","HongKong"]
}
console.log(myJson.bigCity[1]);//打印出Shanghai
myJson.bigCity[0] = "GuangZhou";//第一个元素被赋值为GuangZhou
```



> **遍历**

```js
var myJson = {
"country":"China",
"population":"1.3billion",
"bigCity":["Peking","Shanghai","ShenZhen","HongKong"]
}
for(var i = 0;i < myJson.bigCity.length;i++) {
    console.log(myJson.bigCity[i]);//依次输出Peking,Shanghai,ShenZhen,HongKong
}
```





> **JSON字符串转换为JavaScript对象**



==JSON.parse(a,b)方法将JSON字符串a转换为JavaScript对象==。b是一个可选的函数参数。

```js
var JSONString1 = '{"k1":"v1","k2":"v2"}';
console.log(JSON.parse(JSONString1));//输出Object {k1: "v1", k2: "v2"}
```



函数参数b按从里到外的顺序作用在对象的所有属性上，最后一个作用的是对象本身：
//对象的每一个属性的值加1

```js
var text = '{ "key1":1, "key2":2, "key3":2.2}';
var obj = JSON.parse(text, function (key, value) {
    if(key === '')//当遇到对象本身时，不进行加1操作
        return value;
    return value+1;//对属性值加1
});
console.log(obj);//输出Object {key1: 2, key2: 3, key3: 3.2}
```





> **JSON对象转换为JSON字符串**



==JSON.stringify(a,b,c)，a是待转换的JSON对象==，b和c为可选参数。

```js
var JSONObject = {"k1":"v1","k2":"v2"};
JSON.stringify(JSONObject);//JSON对象转换为JSON字符串
```



==参数b为函数时，该函数按照从里到外的顺序处理JSON对象的每一个属性，最后一个处理的是JSON对象本身，处理完后再转为JSON字符串==
//对象的所有属性值加1，再转为字符串

```js
var JSONObject = {"k1":1,"k2":2.2};
var JSONString = JSON.stringify(JSONObject,function(k,v){
    if(k === '')//处理到了JSON对象本身
        return v;
    return v+1;//所有的属性的值加1
});
console.log(JSONString);//输出{"k1":2,"k2":3.2}
```



==参数b还可以是数组，数组存储的是属性的名字，用来指定只转换哪些属性==
//转换对象中特定的属性

```js
var JSONObject = {"k1":1,"k2":2.2,"k3":3};
var JSONString = JSON.stringify(JSONObject,["k1","k2"]);
console.log(JSONString);//输出{"k1":1,"k2":2.2}
```



这里简单介绍一下c：

```js
var str = ["name":"Tom","age":16];
var obj1 = JSON.stringify(str);
var obj2 = JSON.stringify(str,null,4);

console.log(obj1);  //输出{"name":"Tom","age":16}

console.log(obj2); //输出
//{
//    "name": "Tom",
//    "age": 16
//}
```

==参数c：文本添加缩进、空格和换行符，如果 c 是一个数字，则返回值文本在每个级别缩进指定数目的空格，==如果 c 大于 10，则文本缩进 10 个空格。









#### 内置对象

> **Math类**

* Math.E--- e     Math.PI--- 圆周率     Math.SQRT2--- 2的平方根     Math.LN2---2的自然对数



* 随机数（返回数的范围为（0，1））
  `console.log(Math.random());`//输出0.1493135392665863
  ==Math.ceil//取大于该数的一个整数（4.3-->5）==
  ==Math.floor//取小于该数的一个整数（4.3-->4）==
  Math.round
  在一个区间内抽取随机数
* **Math.round(Math.random()*(最大区间值-最小区间值)+（最小区间值）)***







> **平方根**

==Math.sqrt(x)返回x的平方根==

```js

Math.sqrt(4);//2

Math.sqrt(2);//1.4142135623730951
```





> **四舍五入**

==Math.round(x)返回x四舍五入后的整数==

```js
Math.round(1.5);//2
Math.round(1.49);//1
```





> **求最值**

==Math.max(x1,x2,....xn)返回参数的最大值，参数个数不限==

```js
Math.max(1,2,34,100);//100
Math.max(-1,-2,-34,-100);//-1
```



==Math.min(x1,x2,....xn)返回参数的最小值==

```js
Math.min(1,2,34,100);//1
Math.min(-1,-2,-34,-100);//-100
```



==求数组里面的最值(apply())==

```js
let grade = [12,3,7,34,124];
console.log(Math.max.apply(null,grade));
```




涉及数字计算还有许多方法，可以直接百度JS Math对象



> **异常处理**

==try-catch捕获和处理错误==
用法如下

```js
try {
    //运行时可能出错的代码
}catch(err) {
    //处理出现的错误
}
```







> **时间的表示方法(获取当前时间)**



* **时间戳**

==**const date = new Date();//获取的是当前的时间**==
console.log(date);//返回的是一个对象（object）类型
console.log(date*1);//返回从1970年到现在的毫秒数（时间戳）

==**second=date.getTime();//返回当前的毫秒数，该数值是一个数字**==

==**new Date(second)将时间戳转化为当前的时间格式**==





* **时间差的计算**

方法一

```js
const start = Date.now();
for(let i = 0;i < 20000000;i++){}
const end = Date.now();
cosole.log((end-start)/1000+"秒");
```



方法二

```js
console.time("for");
for(let i=0;i<2000000000000;i++){}
console.timeEnd("for");
```



* **自定义时间**

```js
const date = new Date("1990-9-22 3:22:18");
console.log(date);
console.log(date.getMonth());
```



```js
const date = new Date(1990,2,22,13,22,19);
console.log(date);
```



```js
const param = [1990,2,22,13,22,19];
const date = new Date(...param);
console.log(date);
```





* **时间戳和日期时间相互转化**

日期时间转化为时间戳

```js
const date = new Date("1999-08-22");
console.log(date*1);
console.log(Number(date));
console.log(date.valueof());
console.log(date.getTime());
```



时间戳转化为日期

```js
const timestamp = date.valueOf();
console.log(new Date(timestamp));
```





* **当前时间的显示**

Date()							     返回当日的日期和时间。
getDate()						   从 Date 对象返回一个月中的某一天 (1 ~ 31)。
getDay()						     从 Date 对象返回一周中的某一天 (0 ~ 6)。//==这里0表示星期日==
getMonth()						从 Date 对象返回月份 ==(0 ~ 11)。==
getFullYear()		              从 Date 对象以四位数字返回年份。
getHours()						返回 Date 对象的小时 (0 ~ 23)。
getMinutes()					返回 Date 对象的分钟 (0 ~ 59)。
getSeconds()					返回 Date 对象的秒数 (0 ~ 59)。
getMilliseconds()			返回 Date 对象的毫秒(0 ~ 999)。



使用方法

==var dateobj=new Date();==

==dateobj.getDay()==

注意：因为月份等输出的都是数字，这时我们可以先定义存放了每一个月字符串的数组，并结合数字进行调用！





* **windows对象**

`window.screen.width/height(获取当前设备的宽度和高度)`

`window.innerHeight/window.innerWidth(窗口高度/宽度)`

`window.location(获取window对象的当前url,包括端口号port等)`





==数组，函数都可以看作是对象，或者说一切皆对象==

undefined(定义声明了一个变量却没有被赋值)
null(值为空)
==**undefined和null两者都不具有对象**==

如果对 null 进行 typeof 操作，得到的结果是 object。因此，很多人将 null 当做 JavaScript 中的一个对象。然而事实是， typeof null = 'object' 只是 JavaScript 语言本身的一个 bug。

编程语言最后的形式都是二进制，所以 JavaScript 中的对象在底层肯定也是以二进制表示的。如果底层有前三位都是零的二进制，就会被判定为对象。底层中 null 的二进制表示都是零。所以在对 null 的类型判定时，发现其二进制前三位都是零，因此判定为 object。





















#### 集合

set()方法

（类python集合）(==主要作用为去重==)

> **定义**

`let set = new Set([1,2,3,4,5]);//{1,2,3,4,5}`

==数组转化为集合==



> **添加**

`set.add(1);`



> **字符串转化为集合**

`let set = new Set([..."sdgerh"]);//{"s","d","g","e","r","h"}`



> **获取集合数量**

`console.log(set.size);`



> **判断是否含有某元素**

`console.log(set.has("1"))//true`



> **删除某一个元素**

`set.delete('1');`



> **清空集合**

`set.clear();`



> **集合转化为数组**

```js
let set = new Set(["dfghr","dfg"]);
console.log(Array.from(set));//第一种方法
console.log([...set]);//第二种方法
```





> **数组转化为集合**

```js
let hd = new Set("1234567");
let arr = [...hd].filter(function(item){
return item < 5;
});
hd=new Set(arr);
console.log(hd);


或者：
let hd =new Set( [...hd].filter(item => item < 5));
```



==**我们可以把[...arr]和filter方法里面的item看作是arr里面的每一个元素**==



> **交并集处理**

```js
let a = new Set([1,2,3,4,5]);
let b = new Set([4,5,2,9]);
```



* 并集

`console.log(new Set([...a,...b]));`



* 交集

`console.log(new Set([...a].filter(function(item){return b.has(item)})));`



`console.log(new Set([...a].filter(function(item){return !b.has(item)})));`



> **垃圾回收**

`hd=null`







































#### JS正则表达式

正则表达式提供了字符串字面量，字符类，重复，选择，分组，引用，指定匹配位置，修饰符等功能；
1：字符串字面量（exp:aa匹配的就是字符串aa）
var pattern = /aa/
pattern.test("aa")//true
\n换行符    \f 换页符    \t制表符     \v垂直制表符     \r回车符

2：字符类（定义）
var lowerCharPattern = /[a-z]/;//匹配任意小写字母
var upperCharPattern = /[A-Z]/;//匹配任意大写字母
var numberPattern = /[0-9]/;//匹配任意数字
var mixPattern = /[a-zA-Z0-9]/;//匹配大小写字母，数字

在中括号内**最前面加上^符号表示反向匹配**：匹配和中括号内的正则表达式不匹配的所有字符，比如：
（定义和使用）
var notNumberPattern = /[^0-9]/;
notNumberPattern.test("123");//false
notNumberPattern.test("ahc");//true

\w    [a-zA-Z0-9]  匹配大小写字母以及数字
\W    [^a-zA-Z0-9]  匹配所有非大小写字母以及数字
\d     [0-9]  匹配数字
\D     [^0-9]  匹配所有非数字
一个数字后面紧跟小写字母的正则表达式匹配方法
var pattern = /[0-9][a-z]/;
pattern.test("1a")//true
pattern.test("a1")//false

注意中括号[]的使用，一个中括号表示一个类别
匹配两个连续的数字可以表示为[0-9][0-9]


3:重复类
重复表示指定的字符或者字符串（前面紧邻的字符）可以连续出现多次
exp:var pattern = /a{100}/;

{a,b}中的a,和b都是数字，表示前面的字符至少出现a次，最多出现b次；
var pattern = /at{1,2}/;    //表示a后面最少一个t，最多两个t
pattern.test("at");//true
pattern.test("att");//true
pattern.test("am");//false

{a,}表示前面的字符至少出现a次,最多不限制；
var pattern = /[0-9]{4,}/;//匹配最少四个数字
pattern.test("1234");//true
pattern.test("1");//false

{a}表示前面的字符出现a次

？，表示前面的字符出现一次或者不出现，等价于{0，1}；

+，表示前面的字符（单个）至少出现一次，等价于{1，}；

*，表示前面的字符（单个）至少出现一次，等价于{0，}；（可以不出现）
var pattern = /A[0-9]*B/;//匹配A和B之间为空或者只有数字
pattern.test("AB");//true
pattern.test("A1B");//true
pattern.test("AaB");//false

在JavaScript中，使用\实现特殊符号的普通化，又叫做转义：
var pattern1 = new RegExp("\?");//匹配一个问号
var pattern2 = /\+{4}/;//匹配四个加号



4：选择类
选择使用符号|来实现，比如0|1表示匹配0或者1，\d|a表示匹配数字或者字母a
exp:
[0-9]|[a-z]匹配的是字符串1ABCa中的子串1还是a?
JavaScript会先挑选左边的子正则表达式[0-9]进行匹配，匹配成功后立即结束，所以匹配上的子串是1

如果想要限制|符号的作用范围，需要将目标作用范围用圆括号包含在内，如：
var pattern = /(0|1)ABC/;//选择符号仅仅作用在0和1上，而不是像上面的例子一样作用在整个正则表达式中

编写的正则表达式就是一个模型，匹配符合该模型的一切内容，//里面包含一个完整的正则表达式
[]里面是其中的一个特征
{}通常用来限制前面字符的出现次数
(|)通常用于选择



5：分组类
var pattern = /hello{3}/;重复只能作用于紧邻符号的前面一个字符上
pattern表达的意思是字母o必须重复三遍，而不是单词hello必须重复三遍。
如果要表达单词hello必须重复三遍的意思，我们需要用到分组。
var pattern = /(hello){2}/;//匹配字符串hellohello



6：引用类
需要用到引用的情况：
以数字开头，中间是若干个字母，以数字结尾，并且开头的数字和结尾的数字相同，
这个时候用前面所有介绍过的方法都不可行，无法确保开头的数字和结尾的数字相同。

后面可以用\1引用编号为1（数该字符串左边有几个左括号，第几个编号就是几）的子表达式，依次类推，比如：
var pattern = /(A|B)(\d{5})not([0-9])\1\2/;

注意：在使用[0-9][A-Z]等匹配的时候，默认情况下匹配一个字符，特殊情况（大于1）使用重复{}；




7：匹配位置
var startPattern = /^[0-9]/;//匹配以数字开头的字符串

var endPattern = /ing$/;//匹配以ing结尾的字符串

\b用来匹配单词的边界(该字符前后（取决于\b在字符串的位置）没有字母就匹配)
exp: var boundaryPattern = /\bOK\b/;//匹配单词OK


\B用来匹配非单词的边界，与上面的\b相反(该字符前后（取决于\B在字符串的位置）有字母才匹配)

exp:var pattern = /\Bed/;//ed左侧不能是单词的边界

注意：^[js]\b  与  ^js\b的区别



8：修饰符
修饰符需要放在//符号之后

i表示整个的匹配过程中不考虑单词的大小写
exp:var pattern = /^edU/i;//匹配以字母edu开头，不区分大小写进行匹配
console.log(pattern.test("edu"));//输出true

全局匹配：
g表示执行全局匹配，即找出所有满足匹配的子字符串。比如，已知match()函数返回由匹配结果组成的数组，如果没有匹配到返回null。
不用g修饰时：
var pattern = /[a-z]/;//匹配小写字母
console.log("a1b2c3".match(pattern));//输出["a", index: 0, input: "a1b2c3"]
用g修饰时：
var pattern = /[a-z]/g;//全局匹配小写字母
console.log("a1b2c3".match(pattern));//输出["a", "b", "c"]


多行模式：
有的时候，需要匹配的字符串很长，分为很多行（即中间有换行符号）。
m在多行模式中执行匹配，即：符号^不仅匹配整个字符串的开头，还匹配每一行的开头，&不仅匹配整个字符串的结尾，还匹配每一行的结尾。
var pattern = /[0-9]$/m;//多行匹配以数字结尾的字符串
var string = "1\nhello";//字符串在两行，中间的\n是换行符
console.log(pattern.test(string));//输出true


正则表达式的使用

search(a)方法
参数：a为正则表达式。
功能：返回字符串中与该正则表达式匹配的第一个子串的起始位置（即下标），无匹配返回-1。
var pattern = /[0-9]/;
var string = "a3b2c1";
console.log(string.search(pattern));//输出1

split(a)方法
参数：a是字符串或者正则表达式；
功能：以a为分隔符分隔原来的字符串；
返回值：分割后形成的子字符串数组。
console.log("a1b2c3d".split(/[0-9]/));//以数字为分隔符，输出["a", "b", "c", "d"]


replace(a,b)方法
参数：a是正则表达式，b是字符串；
功能：用b替换掉第一个和a匹配的子串，如果a中有修饰符g，替换掉所有子串；
返回值：被替换后的字符串。
var pattern1 = /[0-9]/;
var pattern2 = /[0-9]/g;
var string = "a1b2c3";
console.log(string.replace(pattern1,"A"));//部分替换，输出aAb2c3
console.log(string.replace(pattern2,"A"));//全部数字被替换，输出aAbAcA

复杂的情况：b还可以是子表达式$1、$2等，$1等会先被替换为与它匹配的子串。比如：
var pattern = /([0-9])[A-Z]/g;
var string = "1A,2B,3C,1";
console.log(string.replace(pattern,"$1"));//输出1，2，3，1
上面的$1指的是与子表达式[0-9]匹配的子字符串，比如第一个匹配1A中$1指的是1，第二个匹配2B中$1指的是2，依次类推。















#### DOM文档元素操作

> **元素的获取**

* **通过id获取元素**

文档元素一般都有一个id属性，它的值在本文档中唯一；
其中document表示整个文档，==getElementById()==是document对象的一个方法，//选择单个元素节点
参数是id属性的值myId;注意==里面的标签要使用双引号标识==

```js
<p id="myId">这是我学习JavaScript的网址：</p>//定义标签
var pElement = document.getElementById("myId");//获取id内容
window.alert(pElement.innerText);//对内容进行显示
```



* **通过类名获取文档元素**

文档元素的类名不唯一（存在多个文档元素的类名相同的情况）,注意==要给获取到的元素添加数组下标标识[0]==

```js
<p class="myName">段落</p>
<a class="myName" href="https://www.educoder.net">这是一个链接</a>

var myNodeList = document.getElementsByClassName("myName");//获取文档元素数组

window.alert(myNodeList[0].innerText);
```





* **通过标签名（<p><img>）获取文档元素**

```js
<div id="div1">
    <p id="p1">文本1</p>
    <p id="p2">文本2</p>
    <a name="a1">链接</a>
</div>
<div id="div2">
    <p id="p3" name="a1">文本3</p>
</div>
var allDiv = document.getElementsByTagName("div");//获取文档元素数组
window.alert(allDiv[0]);

var allLink = allDiv[0].getElementsByTagName("a");//获取标签内部的子元素


```



* **querySelector和querySectorAll方法**

```js
var myClassElement = document.querySelector(".myClass");//选择单个元素节点
console.log(myClassElement);//只能获得第一个类名为myClass的元素。

var pElement = document.querySelectorAll("p");//获取包含指定标签的数组
```





> **节点树上的操作**

```html
<body>
<div id="div1">
    <div class="cl1">
        <p>文本</p>
        <a>超链接</a>
    </div>
    <div class="cl2">
        <select id="se">
            <option>红</option>
            <option>黄</option>
            <option>蓝</option>
        </select>
    </div>
</div>
</body>
```



* 获取最外层的div节点

`var div1 = document.getElementById("div1");`

* 获取它的第一个子节点（class值为cl1的节点）

`var cl1 = div1.firstElementChild;`

* 获取cl1的最后一个子节点，即a节点

```js
var aElement = cl1.lastElementChild;
//获取a标签的文本并输出
console.log(aElement.innerText);//超链接
//获取a标签的兄弟前一个标签
var left = aElement.previousElementSibling;//p标签
//获取后一个兄弟标签
var right = left.nextElementSibling;//a标签
```



* 子节点列表

```js
var selectTag = document.getElementById("se");
console.log(selectTag.children[0].innerText);
console.log(selectTag.children[1].innerText);
console.log(selectTag.children[2].innerText);


```



> **属性值的获取**(title值等)

1：`<a href="https://www.educoder.net" target="_blank">EduCoder</a>`
2：`var aElement = document.getElementsByTagName("a").[0];`
3：`var hrefValue = aElement.href;`
4:`console.log(hrefValue);`//输出https://www.educoder.net

或者：
`console.log(aElement.getAttribute("href"));`//输出https://www.educoder.net

==两者区别：第一种方法返回的是一个实际的值，而第二个返回的是一个字符串==



==注意：class等文档元素的属性，不能直接用文档元素对象.class来获取==
解决方案：

```js
<a class="aClass" id="aId">超链接</a>
document.getElementById("aId").className;//返回"aClass"
document.getElementById("aId").getAttribute("class");//返回"aClass"
```





> **属性值的设置**

```js
<a id="a1" href="https://www.google.com">EduCoder</a>
document.getElementById("a1").href="https://www.educoder.net";
```



需要注意：==标签之间的文本用innerText属性表示==，要修改上面超链接里面的文本，需要这样：
`document.getElementById("a1").innerText="educoder";`

当然,innerText完全可以被性能更好，被更多浏览器支持的==textContent==取代。

或者使用==setAttribute()方法==
`document.getElementById("a1").setAttribute("href","https://www.educoder.net");`//两个参数分别为属性名称和属性值



innerText里面可以包含标签

`<a herf="www.xiaohui.com">点我</a>`



==把null赋值给变量来释放变量的内存；==



使用==nodeValue==属性获取和更新文本节点

```js
<li id="one"><em>fresh</em>tigs</li>

document.getElementById("one".firstchild/.nextSibling.nodeValue)//返回text文本节点里面的内容tigs


```







> **创建节点**(createElement)

document.createElement("tagName")用来创建一个新的Element节点（即文档元素，a,p,img等）

```js
var newA = document.createElement("a");//创建超链接节点
newA.src = "https://www.educoder.net";//设置超链接的目的地址
```



创建一个form节点，然后赋值给变量newNode，设置节点的id值为myForm，method值为post:

```js
var newNode = document.createElement("form");
newNode.method = "post";
newNode.id = "myForm";
```





> **插入节点**

* **appendChild()**

  ```js
  var node1 = document.getElementById("s1");//选择要增加的父节点
  var node2 = document.createElement("option");//增加一个option节点
  node2.innerText = "湘潭";//增加节点里面的内容
  node1.appendChild(node2);//添加到指定的区域
  ```

  



* **insertBefore()[可以指定插入节点的位置]**

```js
var pNode = document.getElementById("s1");//选择要增加的父节点
var node1 = document.createElement("option");//增加一个option节点
node1.innerText = "湘潭";//增加节点里面的内容
var node2 = document.getElementById("zz");
//将内容为"湘潭"的节点插入到内容为"株洲"的节点前面
pNode.insertBefore(node1,node2);
```



==注意：创建节点和插入节点要结合使用
此外，还可以使用**setAttribute(name,value)来设置属性值（id,class,title等**），使用**getAttribute来获取属性值的内容**==





> **删除节点（removeChild()）**

```html
<ul> 
<li>提子</li>
  <li>车厘子</li>
  <li id="child3">荔枝</li>
</ul>
```

第一步：获取父节点，即ul节点：
`var parentNode = document.getElementById("parent");`

第二步：获取待删除的子节点：
`var childNode = document.getElementById("child3");`

第三步：父节点调用removeChild()方法删除子节点：（也可以使用removeAttribute方法）
`parentNode.removeChild(childNode);`





> **替换节点**

方法一：替换节点=删除节点+新增节点

方法二：replaceChild()方法
replaceChild(a,b)的调用者是要被替换的节点的父节点，a是新的节点，b是被替换的节点。

```html
<ul>  
<li id="child1">黄山</li>
  <li id="child2">庐山</li>
  <li id="child3">泰山</li>
</ul>
```


第一步：获取父节点：
var parNode = document.getElementById("parent");

第二步：获取被替换的子节点：
var oldNode = document.getElementById("child3");

第三步：创建新节点：
var newChild = document.createElement("li");
newChild.innerText = "武夷山";

第四步：替换
parNode.replaceChild(newChild,oldNode);



==node的意思是节点==
==nodeName节点名称（p,div...）==
==nodeValue节点内容==
==nodeType节点类型==









#### 事件处理

> **注册事件处理程序**

* 方法1：//为了script与html分离，不建议使用该方法

  ```js
  <button id="button1" onclick="listenButton1()">按钮1</button>
  
  <script>function listenButton1() { alert("监听button1");}</script>
  ```

  

* 方法2

```js
<button id="button2">按钮2</button>

<script>
function listenButton2() {alert("监听button2");}
var button2 = document.getElementById("button2");
        button2.onclick = listenButton2;//获取内容id,接着添加onclick方法
</script>


要注意的是，事件名称的命名是在事件前缀+on;
```





> **文档加载事件**

```js
    <script>
        function loadEvent() {
        alert("Welcome!");
        }       
    </script>
</body>
```



> **鼠标事件**

* click--onclick--按下并且释放鼠标

* dbclick--ondbclick--双击鼠标

* mousedown--onmousedown--按下鼠标按键

* mouseup--onmouseup--释放鼠标按键

* mousemove--onmousemove--移动鼠标

* mouseover--onmouseover--鼠标进入元素

* mouseout--onmouseout--鼠标离开元素

使用方法一：
1：标签内定义对应方法

` <p id="p" onmousedown="downfunc()" onmouseup="upfunc()">点我</p>`

2：定义使用该方法时要做的事情
`function downfunc() {document.getElementById("p").innerText = "鼠标已经按下";}`
`function upfunc() {document.getElementById("p").innerText = "鼠标已经释放";}`



使用方法二：
1：定义标签

```js
<p id="p">text</p>

 <button id="but"> button</button>
```



2：通过addEventListener为按钮绑定一个事件处理程序，用来处理按钮的鼠标单击事件；
在事件处理程序中，通过id获取p元素，赋给变量myElement，然后设置当按钮被单击后，
p里面的文本被改变为clicked；

```js
var myButton = document.getElementById("but");//选择要点击的区域id，并赋值给myButton
            myButton.addEventListener("click",function() {
                var myElement = document.getElementById("p");
                myElement.innerText="clicked";
            })
```





> **键盘事件**（三个只是方法，我们需要做的事情是定义需要出现结果的函数）

* 点击按键

```js
<body onkeypress="keyEvent(event)">
<p>
        keypress event
    </p>
    </body>
    <script>
    function keyEvent(event) {
        console.log("编码是:"+event.which);
    }
</script>
```





* 按下按键

```js
<body onkeydown="downEvent(event)">
</body>
<script>
    function downEvent(event) {
        console.log("编码是:"+event.which);
    }
</script>
```





* 释放按键

```js
<body onkeyup="upEvent(event)">
</body>
<script>
    function upEvent(event) {
        console.log("编码是:"+event.which);
    }
</script>
```



| 属性                                                         | 描述                       | DOM  |
| :----------------------------------------------------------- | :------------------------- | :--- |
| [onkeydown](https://www.runoob.com/jsref/event-onkeydown.html) | 某个键盘按键被按下。       | 2    |
| [onkeypress](https://www.runoob.com/jsref/event-onkeypress.html) | 某个键盘按键被按下并松开。 | 2    |
| [onkeyup](https://www.runoob.com/jsref/event-onkeyup.html)   | 某个键盘按键被松开。       |      |

我们也可以去掉on前缀，直接使用键盘监听来使用，==比如keyup事件就经常用来当表单信息输入完成之后进行一系列的JS操作==

```html
<body>
    <input type="text" id="txt1" />
    <p>提示信息:<span id="txthint"></span></p>
    <script>
      let valueinput = document.getElementsByTagName("input")[0];
      let txt = document.getElementById("txthint");
      valueinput.addEventListener("keyup", () => {
        txt.innerHTML = valueinput.value;//获取输入的内容并输出
      });
    </script>
  </body>
```





> **表单事件**

form有很多子元素，分别表示不同类型的用户输入：例如input表示文本等类型；
select表示下拉列表；button表示按钮。

1：Change事件
当用户输入文本，并且鼠标点击页面上的其他地方后，我们将在控制台打印出用户的输入。

```html
 <form>
        <input id="t1" type="text" onchange="changeEve()"/>
    </form>
<script>
    function changeEve() {
        var e = document.getElementById("t1");
        console.log(e.value);
    }
</script>
```



2：select事件
文本框中的文本被用户选中时发生

```html
 <body>
 <input type="text" value="赵钱孙李，周吴郑王" onselect="selectEve()"/>
 <script>
        function selectEve() { 
            console.log(window.getSelection().toString());
        }
    </script>
    </body>
```



3：submit事件
通常情况下，在submit的事件处理函数中，校验用户的输入是否符合要求，比如密码的长度够不够。

```html
<body>
    <form onsubmit="subEve()">
        <input type="password" id="pw"/>
        <input type="submit" value="提交" />
    </form>
    <script>
    function subEve() {
        var content = document.getElementById("pw").value;
        if (content.length < 6) {
            window.alert("密码不可以小于6位");
        }
    }
    </script>
</body>
```





4:拖动事件
==将元素的draggable属性设置为true，即表示元素支持拖动==。如：下面设置了p元素支持拖动：

```html
<p id="p1" draggable="true">
    元素支持鼠标的拖动
</p>
```



也可以用下面的JavaScript代码设置p为可拖动的：
`document.getElementById("p1").draggable = true;`



ondrag()是元素正在拖动时触发的事件处理程序。
如果元素一直在拖动的过程中，ondrag()会每隔350ms被触发一次

```html
<body>
    <div>
        <p ondrag="dragging(event)" draggable="true">拖动我!</p>
    </div>
    <script>
    function dragging(event) {
        console.log("正在拖动");
    }
    </script>
</body>
```



ondragstart
用户开始拖动元素时触发，可以带有一个event参数，其中的event.target表示拖动的元素

```html
<body>
    <p ondragstart="dragStart(event)"  draggable="true">拖动我!</p>
    <script>
        function dragStart(event) {
            console.log(event.target);
            console.log("你要拖动的文本的内容是："+event.target.innerText);
        }
    </script>
</body>
```



> **事件冒泡**

事件冒泡是指，某个事件触发了某个元素的事件处理程序，接下来，就会自动沿着节点树往根节点的方向依次触发经过的路径上的所有元素的某个事件的处理程序。

事件冒泡不是所有的时候都受到欢迎，有的时候需要控制它的发生，使用event.stopPropagation()即可。

```js
function clickChild() {
   console.log("子");
   window.event?window.event.cancelBubble=true:event.stopPropagation(); 
}
```







> **事件监听器**

概述：事件监听器近来才加入事件处理大家庭，它可以同时触发多个函数，但是在旧的浏览器中不被支持



语法如下：
element.addEventListener('event',functionName,[Boolean]);//三个参数分别表示事件名称，遇到该事件需要的方法（函数），以及是否为捕获方式的事件响应，通常被设置为false

exp:elUsername.addEventListener('blur',checkUsername,false);
注意，这个示例的函数方法去掉了小括号，因为==小括号表示函数会在页面加载到这里时运行==，而不是事件发生时运行

此外，和传统的HTML及DOM事件处理程序不同，当指定需要监听的事件名称时，不需要在名称前面加上“on”这个前缀
如果需要==移除事件监听器可以使用removeEventListener()方法来移除指定元素的事件==，参数和添加方法相同；













#### 浏览器对象模型

> **定时器**

* **window.setTimeout(a,b)**（只会执行一次）


指定函数a在延迟b毫秒时间后执行，即在window.setTimeout(a,b)这句话开始执行的b毫秒之后，再执行a函数。

```js
<body>
    <p onclick="al()">
        单击此处4秒后弹出警告框
    </p>
    <script>
    var id;
    function al() {
        id = window.setTimeout(showAlert,4000);
    }
    function showAlert() {
        window.alert("警告框");
    }
</script>
</body>
```



* ###### 基本使用步骤

a:在文本标签（单击此处弹出警告框）设置onclick事件方法
b:函数调用该方法，并使用setTimeout()函数设置时间
c:定义自定义函数，表示在设置的时间到了之后需要做什么事情



* ###### 取消定时器（window.clearTimeout(id)）

```js
<body>
    <p onclick="al()">
        单击此处4秒后弹出警告框
    </p>
    <p onclick="a2()">
        单击此处取消警告框的弹出
    </p>
    <script>
    var id;
    function al() {
        id = window.setTimeout(showAlert,4000);
    }
    function showAlert() {
        window.alert("警告框");
    }
    function a2() {
        window.clearTimeout(id);
    }
</script>
</body>
```



* ###### 基本使用步骤

  a:设置点击弹出警告框区域方法以及点击取消警告框区域方法
  b：定义弹出框函数
  c:定义点击后的要出现的事件
  d:定义取消弹出框函数





* **setInterval(a,b)：每隔b毫秒，执行一次a函数**

循环定时器，指定时间间隔上重复执行函数

```js
<body>
    <p onclick="updateTime()">
        开始更新时间
    </p>
    <p id="timeContainer">
    </p>
    <script>
    var id;
    function updateTime() {
        id = window.setInterval(showTime,1000);
    }
    function showTime(){        document.getElementById("timeContainer").innerText = new Date();
    }
</script>
</body>
```



* ###### 基本使用步骤

  a:调用方法
  b:定义调用该方法后要做的事情
  取消定时（window.clearInterval(id)）

  

在调用事件处理函数的时候，有的是JS自带的，而有的是自定义的，注意区分
标签内容里面的属性要么是id,要么是特定方法，它们都是要由script进行定义，调用







> **location对象**

location对象就是window.location，记载了浏览器当前所在的窗口的URL（统一资源定位符）信息，它常常被用来实现网页的跳转。

* **页面的跳转**

location.href属性表示当前窗口所在页面的地址，比如，如果我们在本网站的首页（https://www.educoder.net/），打印window.location.href：

```js
<body>
    <script>
        console.log(window.location.href);
    </script>
</body>
```





window.location.href还是可写的，如果把它设置为一个新的地址，当前窗口将立即打开这个新的地址，这是实现页面跳转的一种方式。比如下面的例子：

```js
<body>
    <p onclick="toNew()">
        点我调到EduCoder首页
    </p>
    <script>
        function toNew() {
            window.location.href = "https://www.educoder.net";
        }
    </script> 
</body>
```





* **location的其他属性**(类比日期的使用方法)

```js
<body onload="printInfo()">
    location attribute

    <script>
        function printInfo() {
            var loc = window.location;
            console.log("host:"+loc.host);
            console.log("hostname:"+loc.hostname);
            console.log("pathname:"+loc.pathname);
            console.log("port:"+loc.port);
            console.log("protocal:"+loc.protocal);
            console.log("search:"+loc.search);
        }
    </script>

</body>


```







> **对话框**

1：警告框：window.alert(msg)

2：确认框：window.confirm(msg)   用户在弹出的框里面选择确认或者取消后，会返回true或者false

3：输入框：window.prompt(a,b)弹出一个输入框，供用户输入关键信息。其中a是输入框的提示语，b是输入框里面默认的内容。





> **窗口**

window.open(url,name,specs,replace)用来打开一个浏览器的窗口，它有四个参数：

* url表示窗口里面的文档的地址

* name有两种情况
  1：当name是窗口的名字，浏览器会先判断这个窗口是否已经打开。已经打开则用新的url里面的文档替换这个窗口里面原来的文档，反映到浏览器上是不会有新的标签页打开，
  但是一个已存在的标签页会刷新。
  没有打开则打开一个新的窗口，并且载入url里面的文档

  2：如果name是_blank、_self里面中的任何一个
  _blank
  打开新的窗口，载入地址为url的文档
  _self
  不打开新的窗口，用地址为url的文档替换掉当前的文档



* specs是用来控制新窗口的尺寸等特征，比如值为width=200,height=100时，表示新窗口宽度为200px，高度为100px。



* replace用来控制新的窗口在浏览器的浏览历史里面如何显示。为true表示装载到窗口的url替换掉浏览历史中的当前条目；为false表示装载到窗口的url创建一个新的条目



> **打开和关闭窗口**

```js
<body>
    <p onclick="openNewWindow()">打开新窗口</p>
    <p onclick="closeNewWindow()">关闭新窗口</p>
    <script>
        var w;
        function openNewWindow() {
            w = window.open("Demo1.html", "windowName");
        }
        function closeNewWindow() {
            w.close();
        }
    </script>
</body>
```



注意：上面提及的窗口是要自己事先准备好的，并非JS函数自己生成！









































#### 补充

let number = 99.657

判断是否为整数函数，返回布尔类型·
`console.log(Number.isInteger(number));`

保留小数点后几位函数
`console.log(number.toFixed(2));`



this关键字
当一个函数创建于脚本的最高级别时（既不在另外一个对象也不再其它函数内），它就位于全局作用域或全局上下文中
exp:用this关键字返回windows对象的属性
function windowsSize(){
  var  width = this.innerWidth;
  var  height = this.innerHeight;
return [height,widht];
}

所有全局变量都是windows对象的属性，所以当一个函数在全局上下文中时，可以通过windows对象访问它，和使用属性一样（windows对象最大！）
所谓方法，就是定义在一个对象里面的一个函数

this通常指向的是它的父对象所包含的内容
exp:
var shape ={
width:600,
height:400,
getArea:function(){
return this.width*this.height;
}
};




注意下面两种区分：
1：
var width = 600;
var shape = {width:300};//这是一个对象

var showWidth = function(){
document.write(this.width);
};
showWidth();这里的this指向的是600；

2：
var width = 600;
var shape = {width:300};//这是一个对象

var showWidth = function(){
document.write(this.width);
};
shape.getWidth = showWidth;
shape.getWidth();
因为这里把函数赋值给了一个对象，因此this指向的是·300；













































## JQuery

jQuery只是一个javascript文件，因此jQuery能够实现的javascript也可以实现
jQuery一个最大的特点就是用最简洁的代码实现更多的功能


1:查找元素
在使用JQuery时，经常使用CSS样式选择器来选择元素，因此查找元素,基本选择器,子节点查找器，属性查找器参照CSS文档区域

1.1基本筛选器
:not(selector)               除选择器之外的所有元素（比如div:not('#summary')）

:first                             选中元素中的第一个元素

:last		    选中元素中的最后一个元素

:even		    选中元素中索引编号为偶数的元素

:odd                             选中元素中索引编号为奇数的元素

:eq(index)                     选中元素中索引编号为参数中指定数字的元素

:gt(index)                      选中元素中索引编号大于参数中指定数字的元素

:lt(index)                       选中元素中索引编号小于参数中指定数字的元素（比如$('li:lt(3)').hide().fadeIn(1500)）;

:header                        选中所有的<h1>到<h6>元素（比如$(':header').addClass('headline'),选中所有的<h1>到<h6>元素并添加类属性）

:animated                     选中正在动画的元素

:focus                           选中当前正在聚焦的元素





1.2内容筛选器
:contains('text')                  包含参数中指定文本的元素

:empty                               没有子节点的所有元素

:parent                               拥有子节点（文本或子元素）的元素

:has(selector)                     至少包含一个匹配选择器的元素（比如，div:has(p)匹配所有包含<p>元素的div元素）





1.3可见性筛选器
:hidden                                 所有隐藏的元素

:visible                                  所有在页面布局中占据空间的元素
不会选中的元素包括:display:none; height/width:0;祖先元素被隐藏
会选中的元素包括：visibility:hidden;opacity:0;因为它们都会在布局中占据空间



1.4表单
:input			选中所有的input元素

:text			选中文本类型的input元素


:password		选中所有密码类型的input元素


:radio			选中所有的单选按钮


:checkbox			选中所有的复选框


:submit			选中所有的提交按钮


:image			选中所有的图片按钮


:reset			选中所有的重置按钮


:button			选中所有的button元素


:file			选中所有的文件选择器


:selected			选中下拉列表中所有的列表项（option）


:enabled			选中所有可用的表单元素（所有表单元素的默认状态）


:disabled			所有被禁用的表单元素


:checked			所有被选中的单选按钮或复选框



2：将jquery选取的结果缓存在变量中
创建jQuery对象（变量）需要消耗时间,CPU资源和内存
变量声明：$listtems = $('li');//对于要经常使用的元素可以将其赋值给一个变量，减少CPU负担


3：循环
exp:
<li id="one" class="hot"><em>fresh</em>figs</li>
<li id="two" class="hot">pine nuts</li>
<li id="three" class="hot">honey</li>
<li id="four">balsamic vinegar</li>


$('li em').addClass('seasonal');
$(li.hot).addClass('favorite');

通过以上jQuery语句，第一个选择器只应用于一个元素，并为其class属性设置新的值；第二个选择器同时作用于三个值；
jQuery的这一种选择方式就类似于正则表达式，符合所规定的规则就选中；要注意的是对于元素之间的组合用空格隔开，而对于元素与class之间的组合需要用 . 来组合链接


4：链式操作
$('li[id != "one"]').hide().delay(500).fadeIn(1400);
如果需要在同一个选取结果上使用多个jQuery方法，可以列出这些方法并用点号隔开，这种方法就叫做链式操作；
要注意的一点是，如果其中的一个方法不工作了，那么剩下的方法也会停止工作；





5：检测页面是否已经可以使用
使用方法：
$(document).ready(function{
    //当DOM树构建完成之后需要做的事情
})

简写：$(function(){

});



6:获取元素内容
6.1: .html
$('ul').html();-----------使用该方法会返回ul下面的所有内容（包括元素节点名称，即整个DOM树都会获取返回）
$('li').html();----------它只会返回第一个li节点，使用.each()方法可以获取到所有的li节点

6.2: .text()
$('ul').text();----------使用该方法获取ul下面所有的文本内容（注意，这里是所有）

如果要获取<input>或<textarea>元素的内容，则使用.val()方法


6.3：添加内容(.html()方法返回第一个内容，而text()方法返回所有内容)
exp1:
var $listHTML = $('ul').html();
$('ul').append($listHTML);
结果将会添加到<li>（每一个）元素之后


exp2:
var $listText = $('ul').text();
$('ul').append('<p>' + $listText + '</p>');
结果将会添加到<ul>元素之后



exp3:
var $listItemHTML = $('li').html();
$('li').append('<i>' + $listItemHTML + '</i>');//$('li')表示每一个
结果只选择第一个<li>元素的内容添加到每一个<li>元素后面


exp4:
var $listItemText = $('li').text();
$('li').append('<i>' + $listItemText + '</i>');
结果将会获取到所有<li>元素里面的内容并且把所有的内容添加到每一个<li>元素后面





7:修改内容
7.1$('li:contains("pine")').text('almonds');      
这一行代码的作用是选取内容包含pine的所有列表项，然后使用.text()方法将匹配的元素的文本修改为almonds;

7.2$('li.hot').html(function(){
    return '<em>'+$(this).text()+'</em>';
    });
这段代码选中所有类属性为hot的列表项，然后使用.html()方法更新每个元素的内容；


7.3$('li#one').remove();
选取id属性为One的<li>元素，然后使用remove()方法移除它（该方法不需要参数）




8：添加新内容
插入元素涉及两个步骤：
1：将新元素创建为jquery对象
2：使用一个方法将内容插入到页面中
3:（.before()）<li>(.prepend())item(.append())</li>(.after())

8.1$('ul').before('<p class=""notice>Just updated</p>');
选取ul元素,并在该元素前面使用.before()方法向列表的前面添加一个内容

8.2:$('li.hot').prepend('+');
选取所有的li元素里面的类属性为hot，然后使用Prepend()方法在选定的li元素的内容前面添加‘+’；

8.3
let $newListItem = $('<li><em>free</em>soy sauce</li>');
$('li:last').after($newlistItem);
创建一个新的<li>元素节点，然后把该元素节点添加到最后一个<li>元素的后面；




9:操作，获取和设置属性值
9.1可以使用attr()和removeAttr()方法来操作任何元素的任何属性
如果使用attr()方法来更新一个不存在的元素，就相当于创建了该属性并赋予了指定的值

9.2使用addClass()和removeClass()方法可以用来添加或者移除class属性，由于一个元素可以设置多个类属性，当我们使用该方法的时候，可以仅仅只是移除选定的类而不会影响到其他的类；
$('li#three').removeClass('hot');
找到id的值为three的元素节点，然后从该元素节点移除类名为hot；

$('li.hot').addClass('favorite');
找到类名称为hot的li标签，并且添加favorite类；


$('ul').attr('id','groud');
选择标签名为ul的元素，然后为其添加id名称为groud的id;



10:获取和设置CSS属性（针对的是在CSS文件当中已经定义好了的样式）
10.1CSS属性的获取
获取CSS属性时，需要在小括号中指定需要获取哪一个属性，如果匹配结果包含多个元素，该方法会返回第一个元素的值
exp:
let backgroundColor=$('li').css('backgroud-color');
获取第一个列表项中的背景色，并赋值给变量backgroundColor;

10.2CSS属性的设置
设置CSS属性的时候，需要在小括号中使用第一个参数来指定属性名称，后面接一个逗号，然后用第二个参数来指定属性值，该方法会更新所有匹配的元素；
exp:
设置一个属性
`$('li').css('background-color',"#000");`
当使用像素为单位的尺寸时，可以使用+=和-=操作符来增加或者减少属性的值
$('li').css('padding-left','+=20');

设置多个属性(使用对象描述标记更新多个属性)
$('li').css({
    'background-color':'#000',
    'font-family':'Corier'
    });


11:each()方法操作选取结果的每一个元素
exp:
$(function(){
  $('li').each(function(){
  let ids=this.id;
  $(this).append('<span class="order">' + ids + '</span>');
});
 });


12:事件
12.1事件方法
$(function(){
   var ids='';
   var $listItems = $('li');
//使用选择器找到页面中的所有列表项，这个jquery结果会多次使用，所以将其保存到变量$listItems中；


  $listItems.on('mouseover click',functio(){//指定两个事件用空格隔开
   ids=this.id;//这里的this代替的（指向）是li元素
   $listItems.children('span').remove();
   $(this).append('<span class="priority">' + ids + '</span>');
      });

$listItems.on('mouseout',function(){
    $(this).children('span').remove();
     });
   });



12.2事件对象
每个事件处理函数都会获得一个事件对象，该对象包含和此事件相关的方法及属性
type                                 事件类型（比如click,mouseover等）                  
which                               被按下的按钮或键
data                                 当事件发生时传入该函数的一些额外信息
target                               发生这个事件的DOM元素
pageX                              鼠标相对可视区域左边缘的位置
pageY                              鼠标相对于可视区域上边缘的位置
timeStamp                       事件发生时间距离1970年1月1日的毫秒数


使用方法：
当用户点击一个列表项(li)时，事件发生的日期以及触发的事件类型会写入列表项的后面
$(function(){
    $('li').on('click' function(e){//使用字母e作为事件对象的缩写
     $('li span').remove();//移除<li>元素中存在的所有<span>元素，达到切换显示的目的
       let date = new Date();
      date.setTime(e.timeStamp);//创建一个新的日期对象，并将其时间设置为事件发生的时间
      let clicked = date.toDateString();//将时间发生的时间转换为可读的日期
      $(this).append('<span class="date">' + clicked + ' ' + e.type + '</span>');//将点击该列表项的日期时间以及事件类型写入到该类表项内容后面
      });
     });



exp2:
$(function(){
let listItem,itemStatus,eventType;

$('ul').on(
'click mouseover',
':not(#four)',//排除id属性为four的元素
{status:'important'},//事件处理程序需要使用的额外信息以对象描述标记的方式传递
function(e){
  listItem='Item:'+e.target.textContent+'</br>';//显示用户操作的对象
  itemStatus='Status:'+e.data.status+'</br>';//传入函数中的额外信息
  eventType='Event:'+e.type;//事件的类型
  $('#notes').html(listItem+itemStatus+eventType);
   }
  );
});





13:特效
.show()				显示选中的元素
.hide()				隐藏选中的元素
.toggle()				在选中的元素上切换显示和隐藏的状态（对当前状态进行切换）
.fadeIn()				淡入选中的元素使其变得不透明
.fadeOut()			淡出选中的元素使其变得透明
.fade To()				修改选中元素的透明度
.fade Toggle()			使用透明度来隐藏或显示选中的元素
.slideUp()				使用滑动效果来显示选中的元素
.sliceDown()			使用滑动特效来隐藏选中的元素
.slideToggle()			使用滑动特效来隐藏或者显示选中的元素（对当前状态进行切换）
.delay()				延迟队列中操作的执行
.stop()				如果一个动画正在运行，就停止它
.animate()				创建自定义的动画

使用方法：
$(function(){//检测页面是否已经加载完成，加载完成就执行函数里面的语句
     $('h2').hide().slideDown();//链式使用，不需要为每一个任务创建新的选取结果，先将其隐藏，才能实现淡入效果
     let $li=$('li');
     $li.hide().each(function(index){//在匿名方法中，index属性的作用相当于计数器，表示当前的<li>元素是第几个
     $(this).delay(700*index).fadeIn(700);
     });
$li.on('click'.function(){
	$(this).fadeOut(700);
     });    
   });




14：CSS属性动画
.animate({写入你想要改变的类型}，动画持续的时间(以毫秒为单位)，linear(变化均匀)|swing(中间速度快，开始和结束时间慢)，这里输入动画结束的时候需要执行的函数（回调函数）);
适用范围：该属性可以表现为数字
CSS属性命名规则：border-top-left-radius对应于borderTopLeftRadius

exp:
$(function(){
   $('li').on('click',function(){
   $(this).animate({
   opacity:0.0,
   paddingLeft:'+=80'
    },500,function(){
$(this).remove();
	});
       });
});